{"file_contents":{"README.md":{"content":"# AdBlock Pro v5.0.0 - Tecnolog√≠a de √öltima Generaci√≥n üõ°Ô∏è\n\nEl AdBlock m√°s avanzado del mercado con Machine Learning, detecci√≥n perceptual, NLP, anti-fingerprinting avanzado, an√°lisis de video streams y protecci√≥n integral contra amenazas.\n\n## üöÄ Caracter√≠sticas de Vanguardia\n\n### ü§ñ Tecnolog√≠as de Machine Learning y AI\n- **Detecci√≥n Perceptual Visual**: An√°lisis de caracter√≠sticas visuales de elementos\n  - Detecci√≥n de tama√±os est√°ndar de anuncios (IAB)\n  - An√°lisis de z-index, posicionamiento y comportamiento\n  - Identificaci√≥n de disclosure labels (\"Ad\", \"Sponsored\", \"Patrocinado\")\n  - Detecci√≥n de background images sospechosos\n  \n- **NLP (Procesamiento de Lenguaje Natural)**: \n  - An√°lisis de lenguaje persuasivo (\"Compra ahora\", \"Oferta limitada\")\n  - Detecci√≥n de urgency words (\"R√°pido\", \"Ya\", \"Hoy\")\n  - Identificaci√≥n de exceso de capitalizaci√≥n (SHOUTING)\n  - An√°lisis de s√≠mbolos de moneda y precios\n  \n- **An√°lisis Comportamental**:\n  - Detecci√≥n de redirects en cadena\n  - Identificaci√≥n de nested iframes (ad networks)\n  - An√°lisis de patrones de interacci√≥n sospechosos\n  - Detecci√≥n de target=\"_blank\" masivo\n\n- **CNAME Cloaking Detection**:\n  - Identificaci√≥n de subdominios proxy (ads.ejemplo.com)\n  - Detecci√≥n de tracking paths (/track/, /pixel/, /beacon/)\n  - An√°lisis de patrones de evasi√≥n de bloqueadores\n\n### üé¨ Detecci√≥n Avanzada de Ads en Video Streams\n- **An√°lisis de Streams HLS/DASH**:\n  - Monitoreo de manifests .m3u8 (HLS)\n  - Detecci√≥n de markers #EXT-X-CUE-OUT y #EXT-X-DISCONTINUITY\n  - An√°lisis de manifests .mpd (DASH)\n  \n- **Monitoreo de Video Elements**:\n  - Detecci√≥n de cambios sospechosos en playback rate\n  - Identificaci√≥n de volume boosting (ads)\n  - An√°lisis de quality switches durante ad insertion\n  - Tracking de stream interruptions\n\n### üîí Anti-Fingerprinting Avanzado\n- **Canvas Fingerprint Protection**: Randomizaci√≥n de canvas data\n- **WebGL Spoofing**: Vendor y renderer aleatorios\n- **Audio Context Protection**: Randomizaci√≥n de oscillator frequency\n- **Screen Resolution Spoofing**: Variaci√≥n aleatoria de dimensiones\n- **Battery API Protection**: Niveles de bater√≠a aleatorios\n- **Hardware Concurrency Randomization**: CPU cores variables\n- **Font Fingerprint Protection**: offsetWidth/offsetHeight noise\n- **Media Devices Protection**: deviceID randomization\n- **Client Rects Noise**: Peque√±as variaciones en getBoundingClientRect\n- **Timezone Randomization**: Offset aleatorio\n- **Plugin Array Protection**: Lista vac√≠a para evitar detecci√≥n\n\n### Protecci√≥n Multicapa\n- **üõ°Ô∏è 240+ Reglas de Bloqueo**: Expandida desde 65 a 240+ reglas optimizadas\n  - Dominios de publicidad principales (Google Ads, DoubleClick, Amazon Ads)\n  - Redes m√≥viles (AppLovin, Vungle, Unity Ads, Chartboost, Tapjoy)\n  - Redes program√°ticas (The Trade Desk, Criteo, AppNexus, Rubicon)\n  - Publisher networks (Ezoic, Mediavine, Raptive)\n  - Analytics avanzados (Mixpanel, Segment, Quantcast)\n  - Tracking prevalente (orbsrv.com, meta.me, scorecardresearch)\n  - 30+ dominios de miner√≠a de criptomonedas\n  - Redes emergentes 2024-2025 (Bigo Ads: acobt.tech, etc.)\n\n### Detecci√≥n Inteligente de Amenazas\n- **ü¶† Anti-Malware Heur√≠stico**: \n  - An√°lisis de patrones de c√≥digo sospechoso\n  - Detecci√≥n de eval() maliciosos\n  - Identificaci√≥n de c√≥digo obfuscado\n  - Sistema de scoring inteligente (threshold: 5 puntos)\n  - Bloqueo de scripts con comportamiento an√≥malo\n\n- **‚õèÔ∏è Anti-Miner√≠a de Criptomonedas**:\n  - Detecci√≥n de WebAssembly sospechoso (solo modo agresivo)\n  - An√°lisis heur√≠stico multi-se√±al (threshold: 8 puntos)\n  - Identificaci√≥n de signatures de miner√≠a (CryptoNight, Monero, XMR, etc.)\n  - Bloqueo de objetos de miner√≠a (CoinHive, CryptoLoot, JSEcoin, etc.)\n  - Monitoreo de uso de CPU/memoria\n\n- **üëÅÔ∏è Anti-Tracking Avanzado**:\n  - Bloqueo de analytics (Google Analytics, Mixpanel, Segment, etc.)\n  - Protecci√≥n anti-fingerprinting\n  - Bloqueo de rastreadores de sesi√≥n\n  - Prevenci√≥n de WebSocket sospechosos\n\n### Bloqueo Especializado\n\n#### üé¨ YouTube Ads\n- Interceptaci√≥n de ytInitialPlayerResponse\n- Eliminaci√≥n de adPlacements, playerAds y adSlots\n- Auto-skip instant√°neo de anuncios\n- Bloqueo de anuncios en Shorts\n- Filtrado de overlay ads\n- Manipulaci√≥n de experiment flags\n- Chequeo cada 500ms para m√°xima efectividad\n\n#### üéÆ Twitch Ads\n- Interceptaci√≥n de GraphQL con filtrado espec√≠fico\n- Filtrado de streams m3u8 (elimina marcadores de ads)\n- Eliminaci√≥n de purple screen ads\n- Bloqueo de preroll y midroll\n- Hooks de Twitch.ads API\n- Bloqueo de keywords espec√≠ficos de Twitch\n\n### M√≥dulos de Protecci√≥n Toggleables\n- ‚úÖ Anti-Malware (activable/desactivable)\n- ‚úÖ Anti-Miner√≠a (activable/desactivable)\n- ‚úÖ Anti-Tracking (activable/desactivable)\n- ‚úÖ YouTube Ads (activable/desactivable)\n- ‚úÖ Twitch Ads (activable/desactivable)\n\n### Sistema de Reportes\n- Tracking de amenazas detectadas en tiempo real\n- Categorizaci√≥n de bloqueos (ads, trackers, malware, mineros)\n- Historial de actividad sospechosa\n- Notificaciones de amenazas (configurables)\n\n## üì¶ Instalaci√≥n\n\n### En Brave o Chrome\n\n1. Abre `brave://extensions` o `chrome://extensions`\n2. Activa el \"Modo de desarrollador\" (esquina superior derecha)\n3. Haz clic en \"Cargar extensi√≥n sin empaquetar\"\n4. Selecciona la carpeta de este proyecto\n5. ¬°Listo! La extensi√≥n estar√° activa\n\n### Verificaci√≥n\n\nEjecuta en la terminal:\n```bash\nnode validate-extension.js\n```\n\nEsto verificar√° que todos los archivos necesarios est√©n presentes y la extensi√≥n est√© lista para usar.\n\n## üéØ Uso\n\n### Configurar Nivel de Bloqueo\n\nLa extensi√≥n tiene 3 niveles de bloqueo:\n\n- **B√°sico** üü¢: Bloqueo de red est√°ndar con reglas declarativas\n- **Avanzado** üü° (Recomendado): Incluye bloqueo especializado para YouTube y Twitch + Anti-detecci√≥n\n- **Agresivo** üî¥: M√°ximo bloqueo con filtrado cosm√©tico avanzado + detecci√≥n de WebAssembly\n\n### M√≥dulos de Protecci√≥n\n\nAccede a la pesta√±a \"Privacidad\" para activar/desactivar cada m√≥dulo:\n\n1. **Anti-Malware** ü¶†: Detecta scripts maliciosos y c√≥digo sospechoso\n2. **Anti-Miner√≠a** ‚õèÔ∏è: Bloquea mineros de criptomonedas\n3. **Anti-Tracking** üëÅÔ∏è: Protege contra rastreadores\n4. **YouTube Ads** üé¨: Bloqueo espec√≠fico para YouTube\n5. **Twitch Ads** üéÆ: Bloqueo espec√≠fico para Twitch\n\n### Agregar Sitios a Whitelist\n\n1. Navega al sitio que quieres permitir\n2. Abre la extensi√≥n\n3. Ve a la pesta√±a \"Privacidad\"\n4. En la secci√≥n \"Whitelist\", haz clic en el bot√≥n de a√±adir\n5. El sitio actual se agregar√° a la lista\n\n### Ver Estad√≠sticas\n\nLa extensi√≥n rastrea:\n- **Anuncios**: Total de anuncios bloqueados\n- **Rastreadores**: Scripts de analytics y tracking bloqueados\n- **Malware**: Scripts maliciosos detectados y bloqueados\n- **Mineros**: Intentos de miner√≠a de criptomonedas bloqueados\n- **Sitios**: Dominios √∫nicos donde se bloquearon amenazas\n\n## üîß Estructura del Proyecto\n\n```\n.\n‚îú‚îÄ‚îÄ manifest.json              # Configuraci√≥n Manifest V3\n‚îú‚îÄ‚îÄ background.js              # Service worker de fondo\n‚îú‚îÄ‚îÄ content-script.js          # Script inyectado en p√°ginas\n‚îú‚îÄ‚îÄ injected-script.js         # Script con hooks avanzados y detecci√≥n de amenazas\n‚îú‚îÄ‚îÄ config.js                  # Configuraci√≥n de niveles de bloqueo\n‚îú‚îÄ‚îÄ popup.html                 # Interfaz del popup (dise√±o cybersecurity)\n‚îú‚îÄ‚îÄ popup.js                   # L√≥gica del popup\n‚îú‚îÄ‚îÄ rules.json                 # 210+ reglas de bloqueo de red\n‚îú‚îÄ‚îÄ validate-extension.js      # Script de validaci√≥n\n‚îú‚îÄ‚îÄ icon16.png                 # Icono 16x16\n‚îú‚îÄ‚îÄ icon48.png                 # Icono 48x48\n‚îî‚îÄ‚îÄ icon128.png                # Icono 128x128\n```\n\n## üõ†Ô∏è Tecnolog√≠as\n\n- **Manifest V3**: √öltima versi√≥n de la API de extensiones de Chrome\n- **Declarative Net Request**: Bloqueo eficiente de red (210 reglas)\n- **Content Scripts**: Modificaci√≥n del DOM\n- **Injected Scripts**: Hooks a nivel de p√°gina con detecci√≥n heur√≠stica\n- **Chrome Storage API**: Persistencia de configuraci√≥n\n- **Service Workers**: Background processing eficiente\n\n## üîí Privacidad y Seguridad\n\nEsta extensi√≥n:\n- ‚úÖ NO recopila datos personales\n- ‚úÖ NO env√≠a informaci√≥n a servidores externos\n- ‚úÖ Toda la configuraci√≥n se almacena localmente\n- ‚úÖ C√≥digo abierto y auditable\n- ‚úÖ Sin telemetr√≠a ni tracking\n- ‚úÖ Cumple con las pol√≠ticas de privacidad de Brave/Chrome\n\n## üé® Interfaz\n\nDise√±o profesional tipo cyberseguridad con:\n- Gradientes oscuros y efectos de ne√≥n\n- Animaciones fluidas\n- Toggle switches para cada m√≥dulo\n- Dashboard con estad√≠sticas en tiempo real\n- Gr√°ficos de √∫ltimos 7 d√≠as\n- Indicadores visuales de amenazas\n- Badges de estado por nivel de bloqueo\n\n## üìä Estad√≠sticas de Protecci√≥n\n\nLa extensi√≥n incluye:\n- Panel de resumen con stats r√°pidas\n- Gr√°ficos de bloqueos por d√≠a\n- Top sitios bloqueados\n- Estad√≠sticas por categor√≠a (ads, trackers, malware, mineros)\n- Exportaci√≥n/importaci√≥n de datos\n\n## ‚öôÔ∏è Configuraci√≥n Avanzada\n\n### Detecci√≥n ML (Experimental)\nUsa inteligencia artificial para detectar anuncios no catalogados\n\n### Notificaciones\nRecibe alertas cuando se detecta y bloquea malware o mineros\n\n### Anti-Detecci√≥n\nSistema avanzado para evitar que los sitios detecten el adblocker\n\n## üÜï Novedades en v4.0.0\n\n- ‚ú® Expandidas las reglas de bloqueo de 65 a 210+\n- ü¶† Sistema de detecci√≥n heur√≠stica de malware\n- ‚õèÔ∏è Detecci√≥n inteligente de mineros con an√°lisis de WebAssembly\n- üé¨ Bloqueo mejorado de YouTube con soporte para Shorts\n- üéÆ Bloqueo mejorado de Twitch con filtrado de m3u8\n- üõ°Ô∏è M√≥dulos de protecci√≥n toggleables\n- üìä Sistema de reportes de amenazas\n- üé® Interfaz mejorada con dise√±o cybersecurity\n- üíæ Monitoreo de CPU/memoria para detectar miner√≠a\n- üîç An√°lisis de c√≥digo obfuscado\n\n## üö¶ Compatibilidad\n\n- ‚úÖ Brave Browser\n- ‚úÖ Google Chrome\n- ‚úÖ Microsoft Edge (basado en Chromium)\n- ‚úÖ Opera\n- ‚úÖ Otros navegadores basados en Chromium\n\n## üìù Notas T√©cnicas\n\n### Sistema Anti-Detecci√≥n\n\nEl sistema anti-detecci√≥n incluye:\n- Descriptores de propiedades nativos para APIs sobrescritas\n- Jitter aleatorio en la inyecci√≥n de scripts (50-100ms)\n- toString() que devuelve c√≥digo nativo\n- Randomizaci√≥n de fingerprints\n\n### Detecci√≥n Heur√≠stica de Malware\n\nPatterns detectados:\n- eval(atob(...)) - Decodificaci√≥n base64 + ejecuci√≥n\n- document.write(unescape(...)) - Escritura de c√≥digo ofuscado\n- fromCharCode.apply - Generaci√≥n de strings desde c√≥digos\n- XMLHttpRequest + eval - Descarga y ejecuci√≥n remota\n- Base64 encoding extensivo (>200 chars, 3+ veces)\n\nScoring:\n- Cada pattern detectado: +2 puntos\n- Crypto + hash keywords: +3 puntos\n- WebAssembly + monero: +4 puntos\n- C√≥digo minificado grande: +2 puntos\n- **Threshold de bloqueo: 5 puntos**\n\n### Detecci√≥n de Miner√≠a WebAssembly (Solo Modo Agresivo)\n\nSignatures buscadas:\n- cryptonight, monero, xmr, minero, hashrate\n- argon2, scrypt, keccak, blake2b\n- worker + hash combinados\n- Imports sospechosos (thread, atomic, memory.grow)\n\nScoring:\n- Cada signature: +4 puntos\n- Tama√±o >2MB: +1 punto\n- Worker + hash: +3 puntos\n- Imports sospechosos: +1 punto cada uno\n- **Threshold de bloqueo: 8 puntos**\n\n## üìÑ Licencia\n\nEste proyecto es de c√≥digo abierto y est√° disponible para uso personal y educativo.\n\n## ü§ù Contribuciones\n\nLas contribuciones son bienvenidas. Por favor:\n1. Fork el repositorio\n2. Crea una rama para tu feature\n3. Commit tus cambios\n4. Push a la rama\n5. Abre un Pull Request\n\n---\n\n**Desarrollado con ‚ù§Ô∏è para una web sin anuncios y sin amenazas**\n\n*v4.0.0 - Protecci√≥n Total con Detecci√≥n Inteligente*\n","size_bytes":11770},"anti-popup.js":{"content":"// Advanced Anti-Popup and Click-Jacking Protection Module\n\nclass AntiPopupProtector {\n  constructor() {\n    this.blockedPopups = 0;\n    this.blockedClickjacking = 0;\n    this.suspiciousElements = new WeakSet();\n  }\n\n  // Block aggressive popups and popunders\n  blockPopups() {\n    // Override window.open\n    const originalOpen = window.open;\n    const self = this;\n    \n    window.open = function(...args) {\n      const url = args[0];\n      \n      // Check if popup is suspicious\n      if (self.isSuspiciousPopup(url)) {\n        console.log('[AdBlock Pro] Blocked suspicious popup:', url);\n        self.blockedPopups++;\n        return null;\n      }\n      \n      // Allow legitimate popups (user-initiated)\n      const isUserInitiated = self.isUserInitiated();\n      if (!isUserInitiated) {\n        console.log('[AdBlock Pro] Blocked automatic popup:', url);\n        self.blockedPopups++;\n        return null;\n      }\n      \n      return originalOpen.apply(this, args);\n    };\n\n    // Block popunders (new window that goes behind)\n    window.addEventListener('blur', (e) => {\n      if (document.hasFocus()) {\n        const openedWindows = window.length;\n        if (openedWindows > 1) {\n          console.log('[AdBlock Pro] Potential popunder detected and blocked');\n          self.blockedPopups++;\n        }\n      }\n    }, { passive: true });\n  }\n\n  // Check if popup URL is suspicious\n  isSuspiciousPopup(url) {\n    if (!url || typeof url !== 'string') return false;\n    \n    const suspiciousPatterns = [\n      /casino/i,\n      /poker/i,\n      /viagra/i,\n      /cialis/i,\n      /porn/i,\n      /xxx/i,\n      /dating/i,\n      /singles/i,\n      /pills/i,\n      /pharmacy/i,\n      /weight-?loss/i,\n      /click-?here/i,\n      /download-?now/i,\n      /free-?money/i,\n      /prize/i,\n      /winner/i,\n      /congratulations/i\n    ];\n    \n    return suspiciousPatterns.some(pattern => pattern.test(url));\n  }\n\n  // Check if action is user-initiated (within 1 second of user interaction)\n  isUserInitiated() {\n    const timeSinceInteraction = Date.now() - (this.lastUserInteraction || 0);\n    return timeSinceInteraction < 1000;\n  }\n\n  // Track user interactions\n  trackUserInteractions() {\n    ['click', 'keydown', 'touchstart'].forEach(eventType => {\n      document.addEventListener(eventType, () => {\n        this.lastUserInteraction = Date.now();\n      }, { passive: true, capture: true });\n    });\n  }\n\n  // Block click-jacking attempts\n  blockClickjacking() {\n    // Prevent page from being loaded in iframe\n    if (window.self !== window.top) {\n      try {\n        // Check if parent is same origin\n        const parentUrl = window.parent.location.href;\n      } catch (e) {\n        // Cross-origin iframe detected - potential clickjacking\n        console.warn('[AdBlock Pro] Potential clickjacking detected - page loaded in cross-origin iframe');\n        this.blockedClickjacking++;\n        \n        // Break out of iframe\n        if (window.top.location !== window.self.location) {\n          window.top.location = window.self.location;\n        }\n      }\n    }\n\n    // Add X-Frame-Options equivalent via script\n    const meta = document.createElement('meta');\n    meta.httpEquiv = 'X-Frame-Options';\n    meta.content = 'SAMEORIGIN';\n    document.head.appendChild(meta);\n  }\n\n  // Detect and block overlay click-jacking\n  detectOverlayClickjacking() {\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        mutation.addedNodes.forEach((node) => {\n          if (node.nodeType === 1) { // Element node\n            this.checkForClickjackingOverlay(node);\n          }\n        });\n      });\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n  }\n\n  // Check if element is a clickjacking overlay\n  checkForClickjackingOverlay(element) {\n    try {\n      const style = window.getComputedStyle(element);\n      const rect = element.getBoundingClientRect();\n      \n      // Suspicious characteristics\n      const isFullScreen = rect.width >= window.innerWidth * 0.9 && rect.height >= window.innerHeight * 0.9;\n      const isFixed = style.position === 'fixed';\n      const isAbsolute = style.position === 'absolute';\n      const highZIndex = parseInt(style.zIndex) > 9999;\n      const isTransparent = parseFloat(style.opacity) < 0.1;\n      const isInvisible = style.visibility === 'hidden' || style.display === 'none';\n      \n      // Clickjacking overlay pattern\n      if ((isFixed || isAbsolute) && highZIndex && isFullScreen && (isTransparent || isInvisible)) {\n        if (!this.suspiciousElements.has(element)) {\n          console.warn('[AdBlock Pro] Clickjacking overlay detected and removed');\n          element.remove();\n          this.blockedClickjacking++;\n          this.suspiciousElements.add(element);\n        }\n      }\n    } catch (e) {\n      // Ignore errors\n    }\n  }\n\n  // Block redirect chains\n  blockRedirectChains() {\n    let redirectCount = 0;\n    const maxRedirects = 2;\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    const self = this;\n\n    history.pushState = function(...args) {\n      redirectCount++;\n      if (redirectCount > maxRedirects) {\n        console.warn('[AdBlock Pro] Excessive redirect chain blocked');\n        self.blockedPopups++;\n        return;\n      }\n      return originalPushState.apply(this, args);\n    };\n\n    history.replaceState = function(...args) {\n      redirectCount++;\n      if (redirectCount > maxRedirects) {\n        console.warn('[AdBlock Pro] Excessive redirect chain blocked');\n        self.blockedPopups++;\n        return;\n      }\n      return originalReplaceState.apply(this, args);\n    };\n\n    // Reset counter after navigation completes\n    setTimeout(() => {\n      redirectCount = 0;\n    }, 3000);\n  }\n\n  // Block aggressive notifications\n  blockNotificationSpam() {\n    const originalRequestPermission = Notification.requestPermission;\n    const self = this;\n\n    Notification.requestPermission = function() {\n      console.log('[AdBlock Pro] Notification permission request blocked');\n      self.blockedPopups++;\n      return Promise.resolve('denied');\n    };\n  }\n\n  // Get statistics\n  getStats() {\n    return {\n      blockedPopups: this.blockedPopups,\n      blockedClickjacking: this.blockedClickjacking,\n      total: this.blockedPopups + this.blockedClickjacking\n    };\n  }\n\n  // Initialize all protections\n  initialize() {\n    this.blockPopups();\n    this.trackUserInteractions();\n    this.blockClickjacking();\n    this.detectOverlayClickjacking();\n    this.blockRedirectChains();\n    \n    // Only block notification spam in aggressive mode\n    chrome.storage.sync.get(['blockingLevel'], (result) => {\n      if (result.blockingLevel === 'aggressive') {\n        this.blockNotificationSpam();\n      }\n    });\n    \n    console.log('[AdBlock Pro] Anti-popup protection initialized');\n  }\n}\n\n// Auto-initialize\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    window.antiPopupProtector = new AntiPopupProtector();\n    window.antiPopupProtector.initialize();\n  });\n} else {\n  window.antiPopupProtector = new AntiPopupProtector();\n  window.antiPopupProtector.initialize();\n}\n\n// Export for use in other scripts\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = AntiPopupProtector;\n}\n","size_bytes":7371},"popup.js":{"content":"class PopupUI {\n  constructor() {\n    this.stats = null;\n    this.currentTab = 'overview';\n    this.filterLists = [];\n  }\n\n  async initialize() {\n    console.log('[Popup] Inicializando UI...');\n    \n    this.setupEventListeners();\n    await this.loadCurrentTab();\n    await this.loadStats();\n    await this.startAutoRefresh();\n  }\n\n  setupEventListeners() {\n    const tabBtns = document.querySelectorAll('.tab-btn');\n    tabBtns.forEach(btn => {\n      btn.addEventListener('click', (e) => {\n        const tabName = e.currentTarget.dataset.tab;\n        this.switchTab(tabName);\n      });\n    });\n\n    const toggleProtection = document.getElementById('toggleProtection');\n    if (toggleProtection) {\n      toggleProtection.addEventListener('change', (e) => {\n        this.toggleProtection(e.target.checked);\n      });\n    }\n\n    const elementPickerBtn = document.getElementById('elementPickerBtn');\n    if (elementPickerBtn) {\n      elementPickerBtn.addEventListener('click', () => {\n        this.activateElementPicker();\n      });\n    }\n\n    const addWhitelistBtn = document.getElementById('addWhitelistBtn');\n    if (addWhitelistBtn) {\n      addWhitelistBtn.addEventListener('click', () => {\n        this.addCurrentSiteToWhitelist();\n      });\n    }\n\n    const updateListsBtn = document.getElementById('updateListsBtn');\n    if (updateListsBtn) {\n      updateListsBtn.addEventListener('click', () => {\n        this.updateFilterLists();\n      });\n    }\n\n    const exportBtn = document.getElementById('exportBtn');\n    if (exportBtn) {\n      exportBtn.addEventListener('click', () => {\n        this.exportData();\n      });\n    }\n\n    const importBtn = document.getElementById('importBtn');\n    if (importBtn) {\n      importBtn.addEventListener('click', () => {\n        const fileInput = document.getElementById('importFile');\n        if (fileInput) fileInput.click();\n      });\n    }\n\n    const importFile = document.getElementById('importFile');\n    if (importFile) {\n      importFile.addEventListener('change', (e) => {\n        if (e.target.files && e.target.files[0]) {\n          this.importData(e.target.files[0]);\n        }\n      });\n    }\n\n    const resetBtn = document.getElementById('resetBtn');\n    if (resetBtn) {\n      resetBtn.addEventListener('click', () => {\n        this.resetStats();\n      });\n    }\n\n    const toggleML = document.getElementById('toggleML');\n    if (toggleML) {\n      toggleML.addEventListener('change', (e) => {\n        this.toggleSetting('enableML', e.target.checked);\n      });\n    }\n\n    const toggleNotifications = document.getElementById('toggleNotifications');\n    if (toggleNotifications) {\n      toggleNotifications.addEventListener('change', (e) => {\n        this.toggleSetting('showNotifications', e.target.checked);\n      });\n    }\n  }\n\n  switchTab(tabName) {\n    const tabBtns = document.querySelectorAll('.tab-btn');\n    const tabContents = document.querySelectorAll('.tab-content');\n    \n    tabBtns.forEach(btn => btn.classList.remove('active'));\n    tabContents.forEach(content => content.classList.remove('active'));\n\n    const activeBtn = document.querySelector(`[data-tab=\"${tabName}\"]`);\n    const activeContent = document.getElementById(tabName);\n\n    if (activeBtn) activeBtn.classList.add('active');\n    if (activeContent) activeContent.classList.add('active');\n\n    this.currentTab = tabName;\n    this.loadTabContent(tabName);\n  }\n\n  async loadTabContent(tabName) {\n    switch (tabName) {\n      case 'overview':\n        await this.loadOverview();\n        break;\n      case 'stats':\n        await this.loadStatistics();\n        break;\n      case 'lists':\n        await this.loadFilterLists();\n        break;\n      case 'privacy':\n        await this.loadPrivacySettings();\n        break;\n      case 'settings':\n        await this.loadSettings();\n        break;\n    }\n  }\n\n  async loadCurrentTab() {\n    try {\n      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n      if (tab && tab.url) {\n        const url = new URL(tab.url);\n        const domain = url.hostname;\n        \n        const currentDomainEl = document.getElementById('currentDomain');\n        if (currentDomainEl) {\n          currentDomainEl.textContent = domain;\n        }\n        \n        if (this.stats && this.stats.byDomain && this.stats.byDomain[domain]) {\n          const currentSiteBlockedEl = document.getElementById('currentSiteBlocked');\n          if (currentSiteBlockedEl) {\n            currentSiteBlockedEl.textContent = this.stats.byDomain[domain].total || 0;\n          }\n        }\n      }\n    } catch (error) {\n      console.error('[Popup] Error loading current tab:', error);\n    }\n  }\n\n  async loadStats() {\n    try {\n      const response = await chrome.runtime.sendMessage({ type: 'GET_STATS' });\n      if (!response) return;\n      \n      this.stats = response;\n\n      this.updateElement('quickAds', response.ads || 0);\n      this.updateElement('quickTrackers', response.trackers || 0);\n      this.updateElement('quickMalware', response.malware || 0);\n      this.updateElement('quickSites', response.sites || 0);\n\n      this.updateElement('totalBlocked', response.total || 0);\n      this.updateElement('adsBlocked', response.ads || 0);\n      this.updateElement('trackersBlocked', response.trackers || 0);\n      this.updateElement('minersBlocked', response.miners || 0);\n      this.updateElement('fingerprintBlocked', response.fingerprint || 0);\n\n      const settingsResponse = await chrome.runtime.sendMessage({ type: 'GET_SETTINGS' });\n      if (settingsResponse) {\n        const toggleProtection = document.getElementById('toggleProtection');\n        if (toggleProtection) {\n          toggleProtection.checked = settingsResponse.isEnabled;\n        }\n\n        if (settingsResponse.settings) {\n          this.updateToggle('toggleML', settingsResponse.settings.enableML);\n          this.updateToggle('toggleNotifications', settingsResponse.settings.showNotifications);\n        }\n      }\n\n    } catch (error) {\n      console.error('[Popup] Error loading stats:', error);\n    }\n  }\n\n  updateElement(id, value) {\n    const el = document.getElementById(id);\n    if (el) {\n      el.textContent = value;\n    }\n  }\n\n  updateToggle(id, checked) {\n    const el = document.getElementById(id);\n    if (el) {\n      el.checked = checked;\n    }\n  }\n\n  async loadOverview() {\n    await this.loadCurrentTab();\n  }\n\n  async loadStatistics() {\n    if (!this.stats || !this.stats.history) return;\n\n    const chartBars = document.getElementById('chartBars');\n    if (!chartBars) return;\n    \n    chartBars.innerHTML = '';\n\n    const history = this.stats.history || [];\n    const last7Days = history.slice(-7);\n\n    if (last7Days.length === 0) {\n      chartBars.innerHTML = '<div class=\"empty-state\"><div class=\"empty-state-icon\">üìä</div><div class=\"empty-state-text\">No hay datos hist√≥ricos a√∫n</div></div>';\n      return;\n    }\n\n    const maxValue = Math.max(...last7Days.map(d => d.count || 0), 1);\n\n    last7Days.forEach(day => {\n      const wrapper = document.createElement('div');\n      wrapper.className = 'chart-bar-wrapper';\n\n      const value = document.createElement('div');\n      value.className = 'chart-bar-value';\n      value.textContent = day.count || 0;\n\n      const bar = document.createElement('div');\n      bar.className = 'chart-bar';\n      const height = ((day.count || 0) / maxValue) * 100;\n      bar.style.height = `${height}%`;\n\n      const label = document.createElement('div');\n      label.className = 'chart-bar-label';\n      const date = new Date(day.date);\n      label.textContent = date.toLocaleDateString('es-ES', { weekday: 'short' });\n\n      wrapper.appendChild(value);\n      wrapper.appendChild(bar);\n      wrapper.appendChild(label);\n      chartBars.appendChild(wrapper);\n    });\n\n    const topSitesList = document.getElementById('topSitesList');\n    if (!topSitesList) return;\n    \n    topSitesList.innerHTML = '';\n\n    if (this.stats.byDomain) {\n      const sortedDomains = Object.entries(this.stats.byDomain)\n        .sort((a, b) => b[1].total - a[1].total)\n        .slice(0, 5);\n\n      if (sortedDomains.length === 0) {\n        topSitesList.innerHTML = '<div class=\"empty-state\"><div class=\"empty-state-icon\">üåê</div><div class=\"empty-state-text\">Navega por la web y ver√°s estad√≠sticas aqu√≠</div></div>';\n        return;\n      }\n\n      sortedDomains.forEach(([domain, stats]) => {\n        const item = document.createElement('div');\n        item.className = 'list-item';\n        \n        const badges = [];\n        if (stats.ads > 0) badges.push(`<span class=\"badge\">Ads: ${stats.ads}</span>`);\n        if (stats.trackers > 0) badges.push(`<span class=\"badge badge-warning\">Track: ${stats.trackers}</span>`);\n        if (stats.malware > 0) badges.push(`<span class=\"badge badge-danger\">Malware: ${stats.malware}</span>`);\n        \n        item.innerHTML = `\n          <div style=\"flex: 1;\">\n            <div class=\"list-item-text\" style=\"font-weight: 600; margin-bottom: 4px;\">${domain}</div>\n            <div style=\"display: flex; gap: 6px; flex-wrap: wrap;\">\n              ${badges.join('')}\n            </div>\n          </div>\n          <div class=\"stat-row-value\">${stats.total}</div>\n        `;\n        topSitesList.appendChild(item);\n      });\n    }\n  }\n\n  async loadFilterLists() {\n    try {\n      const settingsResponse = await chrome.runtime.sendMessage({ type: 'GET_SETTINGS' });\n      const container = document.getElementById('filterListsContainer');\n      if (!container) return;\n      \n      container.innerHTML = '';\n\n      if (!settingsResponse || !settingsResponse.filterLists) {\n        container.innerHTML = '<div class=\"empty-state\"><div class=\"empty-state-text\">No hay listas de filtros disponibles</div></div>';\n        return;\n      }\n\n      const filterInfo = [\n        { key: 'easylist', name: 'EasyList', desc: 'Lista principal de anuncios' },\n        { key: 'easyprivacy', name: 'EasyPrivacy', desc: 'Rastreadores y analytics' },\n        { key: 'antiadblock', name: 'Anti-Adblock Killer', desc: 'Bypass detecci√≥n adblock' },\n        { key: 'fanboy_annoyance', name: 'Fanboy Annoyances', desc: 'Popups y elementos molestos' },\n        { key: 'fanboy_social', name: 'Fanboy Social', desc: 'Widgets de redes sociales' },\n        { key: 'malware_domains', name: 'Malware Domains', desc: 'Sitios maliciosos' },\n        { key: 'urlhaus', name: 'URLhaus', desc: 'URLs de malware' },\n        { key: 'adguard_base', name: 'AdGuard Base', desc: 'Filtros AdGuard' }\n      ];\n\n      filterInfo.forEach(info => {\n        const toggle = document.createElement('div');\n        toggle.className = 'feature-toggle';\n        toggle.innerHTML = `\n          <div class=\"feature-info\">\n            <h3>${info.name}</h3>\n            <p>${info.desc}</p>\n          </div>\n          <label class=\"toggle-switch\">\n            <input type=\"checkbox\" data-list=\"${info.key}\" checked>\n            <span class=\"toggle-slider\"></span>\n          </label>\n        `;\n\n        const checkbox = toggle.querySelector('input');\n        if (checkbox) {\n          checkbox.addEventListener('change', (e) => {\n            this.toggleFilterList(info.key, e.target.checked);\n          });\n        }\n\n        container.appendChild(toggle);\n      });\n\n    } catch (error) {\n      console.error('[Popup] Error loading filter lists:', error);\n    }\n  }\n\n  async loadPrivacySettings() {\n    try {\n      const container = document.getElementById('privacyToggles');\n      if (!container) return;\n      \n      container.innerHTML = '';\n\n      const privacyFeatures = [\n        { key: 'canvas', name: 'Canvas Fingerprinting', desc: 'Bloquear rastreo por Canvas' },\n        { key: 'webgl', name: 'WebGL Fingerprinting', desc: 'Bloquear rastreo por WebGL' },\n        { key: 'audio', name: 'Audio Fingerprinting', desc: 'Bloquear rastreo por Audio Context' },\n        { key: 'fonts', name: 'Font Enumeration', desc: 'Bloquear detecci√≥n de fuentes' },\n        { key: 'battery', name: 'Battery API', desc: 'Bloquear Battery Status API' },\n        { key: 'webrtc', name: 'WebRTC Leaks', desc: 'Prevenir fugas de IP WebRTC' },\n        { key: 'hardware', name: 'Hardware Info', desc: 'Ocultar informaci√≥n de hardware' }\n      ];\n\n      privacyFeatures.forEach(feature => {\n        const toggle = document.createElement('div');\n        toggle.className = 'feature-toggle';\n        toggle.innerHTML = `\n          <div class=\"feature-info\">\n            <h3>${feature.name}</h3>\n            <p>${feature.desc}</p>\n          </div>\n          <label class=\"toggle-switch\">\n            <input type=\"checkbox\" data-privacy=\"${feature.key}\" checked>\n            <span class=\"toggle-slider\"></span>\n          </label>\n        `;\n        container.appendChild(toggle);\n      });\n\n      const whitelistResponse = await chrome.runtime.sendMessage({ type: 'GET_WHITELIST' });\n      const whitelistContainer = document.getElementById('whitelistContainer');\n      if (!whitelistContainer) return;\n      \n      whitelistContainer.innerHTML = '';\n\n      if (whitelistResponse && whitelistResponse.whitelist && whitelistResponse.whitelist.length > 0) {\n        whitelistResponse.whitelist.forEach(domain => {\n          const item = document.createElement('div');\n          item.className = 'list-item';\n          item.innerHTML = `\n            <div class=\"list-item-text\">${domain}</div>\n            <button class=\"btn btn-danger\" style=\"padding: 6px 12px; font-size: 10px;\">Eliminar</button>\n          `;\n          \n          const removeBtn = item.querySelector('button');\n          if (removeBtn) {\n            removeBtn.addEventListener('click', () => {\n              this.removeFromWhitelist(domain);\n            });\n          }\n\n          whitelistContainer.appendChild(item);\n        });\n      } else {\n        whitelistContainer.innerHTML = '<div class=\"empty-state\"><div class=\"empty-state-icon\">‚úÖ</div><div class=\"empty-state-text\">No hay sitios en la whitelist</div></div>';\n      }\n\n    } catch (error) {\n      console.error('[Popup] Error loading privacy settings:', error);\n    }\n  }\n\n  async loadSettings() {\n  }\n\n  async toggleProtection(enabled) {\n    try {\n      await chrome.runtime.sendMessage({\n        type: 'TOGGLE_ENABLED',\n        enabled\n      });\n      console.log(`[Popup] Protecci√≥n ${enabled ? 'activada' : 'desactivada'}`);\n    } catch (error) {\n      console.error('[Popup] Error toggling protection:', error);\n    }\n  }\n\n  async toggleSetting(key, value) {\n    console.log(`[Popup] Setting ${key} = ${value}`);\n  }\n\n  async toggleFilterList(listKey, enabled) {\n    try {\n      await chrome.runtime.sendMessage({\n        type: 'TOGGLE_FILTER_LIST',\n        listKey,\n        enabled\n      });\n      console.log(`[Popup] Filter list ${listKey} ${enabled ? 'enabled' : 'disabled'}`);\n    } catch (error) {\n      console.error('[Popup] Error toggling filter list:', error);\n    }\n  }\n\n  async activateElementPicker() {\n    try {\n      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n      if (tab) {\n        await chrome.tabs.sendMessage(tab.id, { type: 'ACTIVATE_ELEMENT_PICKER' });\n        window.close();\n      }\n    } catch (error) {\n      console.error('[Popup] Error activating element picker:', error);\n    }\n  }\n\n  async addCurrentSiteToWhitelist() {\n    try {\n      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n      if (tab && tab.url) {\n        const url = new URL(tab.url);\n        const domain = url.hostname;\n        \n        await chrome.runtime.sendMessage({\n          type: 'ADD_WHITELIST',\n          domain\n        });\n\n        await this.loadStats();\n        console.log(`[Popup] ${domain} a√±adido a whitelist`);\n      }\n    } catch (error) {\n      console.error('[Popup] Error adding to whitelist:', error);\n    }\n  }\n\n  async removeFromWhitelist(domain) {\n    try {\n      await chrome.runtime.sendMessage({\n        type: 'REMOVE_WHITELIST',\n        domain\n      });\n      await this.loadPrivacySettings();\n      console.log(`[Popup] ${domain} eliminado de whitelist`);\n    } catch (error) {\n      console.error('[Popup] Error removing from whitelist:', error);\n    }\n  }\n\n  async updateFilterLists() {\n    try {\n      const btn = document.getElementById('updateListsBtn');\n      if (!btn) return;\n      \n      const originalText = btn.textContent;\n      btn.innerHTML = '<span class=\"loading\"></span> Actualizando...';\n      btn.disabled = true;\n\n      await chrome.runtime.sendMessage({ type: 'UPDATE_FILTER_LISTS' });\n      \n      setTimeout(() => {\n        btn.textContent = '‚úì Actualizado';\n        setTimeout(() => {\n          btn.textContent = originalText;\n          btn.disabled = false;\n        }, 2000);\n      }, 1000);\n\n    } catch (error) {\n      console.error('[Popup] Error updating filter lists:', error);\n      const btn = document.getElementById('updateListsBtn');\n      if (btn) {\n        btn.textContent = '‚úó Error';\n        setTimeout(() => {\n          btn.textContent = 'Actualizar Listas';\n          btn.disabled = false;\n        }, 2000);\n      }\n    }\n  }\n\n  async exportData() {\n    try {\n      const response = await chrome.runtime.sendMessage({ type: 'EXPORT_DATA' });\n      const dataStr = JSON.stringify(response, null, 2);\n      const dataBlob = new Blob([dataStr], { type: 'application/json' });\n      const url = URL.createObjectURL(dataBlob);\n      \n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `adblock-pro-backup-${Date.now()}.json`;\n      a.click();\n      \n      URL.revokeObjectURL(url);\n      console.log('[Popup] Datos exportados exitosamente');\n    } catch (error) {\n      console.error('[Popup] Error exporting data:', error);\n    }\n  }\n\n  async importData(file) {\n    if (!file) return;\n\n    try {\n      const text = await file.text();\n      const data = JSON.parse(text);\n      \n      await chrome.runtime.sendMessage({\n        type: 'IMPORT_DATA',\n        data\n      });\n\n      await this.loadStats();\n      console.log('[Popup] Datos importados exitosamente');\n    } catch (error) {\n      console.error('[Popup] Error importing data:', error);\n    }\n  }\n\n  async resetStats() {\n    if (!confirm('¬øEst√°s seguro de que quieres reiniciar todas las estad√≠sticas?')) {\n      return;\n    }\n\n    try {\n      await chrome.storage.local.set({\n        stats: {\n          total: 0,\n          ads: 0,\n          trackers: 0,\n          miners: 0,\n          malware: 0,\n          fingerprint: 0,\n          social: 0,\n          sites: [],\n          byDomain: {},\n          history: []\n        }\n      });\n\n      await this.loadStats();\n      console.log('[Popup] Estad√≠sticas reiniciadas');\n    } catch (error) {\n      console.error('[Popup] Error resetting stats:', error);\n    }\n  }\n\n  async startAutoRefresh() {\n    setInterval(() => {\n      this.loadStats();\n    }, 3000);\n  }\n}\n\nconst popupUI = new PopupUI();\n\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    popupUI.initialize().catch(error => {\n      console.error('[Popup] Initialization error:', error);\n    });\n  });\n} else {\n  popupUI.initialize().catch(error => {\n    console.error('[Popup] Initialization error:', error);\n  });\n}\n","size_bytes":19183},"content-script.js":{"content":"const blockTracker = {\n  ads: 0,\n  trackers: 0,\n  miners: 0,\n  mlDetections: 0,\n};\n\nlet observerTimeout = null;\nconst OBSERVER_DELAY = 1500;\nconst IDLE_TIMEOUT = 30000;\nlet domObserver = null;\nlet lastActivityTime = Date.now();\nlet idleCheckInterval = null;\n\n// Initialize ML detector\nlet mlDetector = null;\nif (typeof MLAdDetector !== 'undefined') {\n  mlDetector = new MLAdDetector();\n}\n\n// Initialize video stream detector\nlet videoStreamDetector = null;\nif (typeof VideoStreamDetector !== 'undefined') {\n  videoStreamDetector = new VideoStreamDetector();\n  videoStreamDetector.initialize();\n}\n\nconst MINER_SCRIPTS = [\n  'coinhive',\n  'coin-hive',\n  'crypto-loot',\n  'cryptaloot',\n  'jsecoin',\n  'webminepool',\n  'monerominer',\n  'deepminer',\n  'authedmine',\n  'minemytraffic'\n];\n\nconst SUSPICIOUS_KEYWORDS = [\n  'cryptonight',\n  'monero',\n  'wasm_exec',\n  'WebAssembly.instantiate',\n  'cnHashing'\n];\n\nconst COOKIE_BANNER_SELECTORS = [\n  '[id*=\"cookie-banner\"]',\n  '[id*=\"cookie-notice\"]',\n  '[id*=\"cookie-consent\"]',\n  '[id*=\"cookieConsent\"]',\n  '[id*=\"gdpr\"]',\n  '[class*=\"cookie-banner\"]',\n  '[class*=\"cookie-notice\"]',\n  '[class*=\"cookie-consent\"]',\n  '[class*=\"cookieConsent\"]',\n  '[class*=\"gdpr-banner\"]',\n  '[class*=\"cookie-bar\"]',\n  '[class*=\"cookies-eu\"]',\n  '.cc-banner',\n  '.cookie-popup',\n  '#cookieNotice',\n  '#gdprNotice'\n];\n\nconst COOKIE_BANNER_KEYWORDS = [\n  'we use cookies',\n  'this website uses cookies',\n  'este sitio usa cookies',\n  'utilizamos cookies',\n  'accept cookies',\n  'aceptar cookies',\n  'cookie policy',\n  'pol√≠tica de cookies',\n  'cookie settings'\n];\n\nconst YOUTUBE_AD_SELECTORS = [\n  '.ytp-ad-overlay-container',\n  '.video-ads',\n  '#player-ads',\n  '.ytp-ad-module',\n  '.ytp-ad-player-overlay',\n  '.ytp-ad-text-overlay',\n  '.ytp-ad-image-overlay',\n  'ytd-display-ad-renderer',\n  'ytd-promoted-video-renderer',\n  'ytd-banner-promo-renderer',\n  'ytd-statement-banner-renderer',\n  'ytd-video-masthead-ad-v3-renderer',\n  'ytd-primetime-promo-renderer',\n  'ytd-in-feed-ad-layout-renderer',\n  'ytd-ad-slot-renderer',\n  'ytd-promoted-sparkles-web-renderer',\n  'ytd-rich-item-renderer:has(> #content > ytd-display-ad-renderer)',\n  'ytd-reel-video-renderer[is-ad]',\n  '.ytd-mealbar-promo-renderer',\n  '#masthead-ad'\n];\n\nconst TWITCH_AD_SELECTORS = [\n  '.top-nav__menu',\n  '.carousel-ad',\n  '.ad-banner',\n  '[class*=\"commercial\"]',\n  '[data-a-target*=\"ad\"]',\n  '[data-test-selector*=\"ad\"]',\n  '.video-ad',\n  '.video-ad__container',\n  '.tw-c-background-accent',\n  'div[data-a-target=\"video-ad-countdown\"]'\n];\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", init);\n} else {\n  init();\n}\n\nfunction init() {\n  console.log(\"[AdBlock Pro] Content script initializing...\");\n  chrome.storage.local.get([\"isEnabled\", \"whitelist\", \"blockingLevel\", \"antiDetection\"], (result) => {\n    if (chrome.runtime.lastError) {\n      console.error(\"[AdBlock Pro] Error:\", chrome.runtime.lastError);\n      return;\n    }\n\n    const isEnabled = result.isEnabled !== false;\n    const blockingLevel = result.blockingLevel || \"advanced\";\n    const antiDetection = result.antiDetection !== false;\n    \n    console.log(\"[AdBlock Pro] Extension enabled:\", isEnabled, \"Level:\", blockingLevel);\n\n    if (isEnabled) {\n      const whitelist = result.whitelist || [];\n      const hostname = window.location.hostname;\n      const isWhitelisted = whitelist.some((domain) => hostname.includes(domain));\n\n      if (isWhitelisted) {\n        console.log(\"[AdBlock Pro] Site is whitelisted:\", hostname);\n        return;\n      }\n\n      blockAds();\n      blockTrackers();\n      blockMiners();\n      blockCookieBanners();\n      \n      if (blockingLevel === 'advanced' || blockingLevel === 'aggressive') {\n        if (hostname.includes('youtube.com')) {\n          blockYouTubeAds();\n        } else if (hostname.includes('twitch.tv')) {\n          blockTwitchAds();\n        }\n      }\n      \n      observeDOMChanges();\n      injectScript();\n      console.log(\"[AdBlock Pro] Protection active with level:\", blockingLevel);\n    } else {\n      console.log(\"[AdBlock Pro] Protection disabled\");\n    }\n  });\n}\nfunction injectScript() {\n  try {\n    chrome.storage.local.get([\"blockingLevel\", \"antiDetection\"], (result) => {\n      const config = {\n        blockingLevel: result.blockingLevel || \"advanced\",\n        antiDetection: result.antiDetection !== false\n      };\n      \n      window.postMessage({\n        type: \"ADBLOCK_PRO_CONFIG\",\n        config: config\n      }, \"*\");\n      \n      const script = document.createElement(\"script\");\n      script.src = chrome.runtime.getURL(\"injected-script.js\");\n      script.onload = () => script.remove();\n      (document.head || document.documentElement).appendChild(script);\n    });\n  } catch (e) {\n    console.error(\"[AdBlock Pro] Error injecting script:\", e);\n  }\n}\n\nwindow.addEventListener('message', (event) => {\n  if (event.source !== window) return;\n  \n  if (event.data.type === 'ADBLOCK_PRO_THREAT') {\n    try {\n      chrome.runtime.sendMessage({\n        type: 'THREAT_DETECTED',\n        threat: event.data.threat\n      }).catch((err) => {\n        console.warn(\"[AdBlock Pro] Failed to forward threat to background:\", err);\n      });\n    } catch (e) {\n      console.warn(\"[AdBlock Pro] Error processing threat message:\", e);\n    }\n  }\n});\n\nfunction blockAds() {\n  console.log(\"[AdBlock Pro] Blocking ads...\");\n  let blockedCount = 0;\n\n  const scripts = document.querySelectorAll(\"script\");\n  scripts.forEach((script) => {\n    if (!script.src) return;\n\n    const src = script.src.toLowerCase();\n\n    const isAd =\n      src.includes(\"doubleclick\") ||\n      src.includes(\"pagead\") ||\n      src.includes(\"googleads\") ||\n      src.includes(\"adsbygoogle\") ||\n      src.includes(\"amazon-adsystem\") ||\n      src.includes(\"taboola\") ||\n      src.includes(\"outbrain\") ||\n      src.includes(\"/ads/\") ||\n      src.includes(\"/ad.js\") ||\n      src.includes(\"/ads.js\");\n\n    if (isAd) {\n      script.remove();\n      notifyBlock(script.src, \"ad\");\n      blockedCount++;\n    }\n  });\n\n  const iframes = document.querySelectorAll(\"iframe\");\n  iframes.forEach((iframe) => {\n    const src = (iframe.src || \"\").toLowerCase();\n    const id = (iframe.id || \"\").toLowerCase();\n    const className = (iframe.className || \"\").toLowerCase();\n\n    const isAd =\n      src.includes(\"doubleclick\") ||\n      src.includes(\"pagead\") ||\n      src.includes(\"googleads\") ||\n      src.includes(\"/ads/\") ||\n      id.includes(\"ad\") ||\n      id.includes(\"google_ads\") ||\n      className.includes(\"ad\");\n\n    if (isAd) {\n      iframe.remove();\n      notifyBlock(iframe.src || \"iframe-ad\", \"ad\");\n      blockedCount++;\n    }\n  });\n\n  const adSelectors = `\n    [class*='ad-'], [class*='-ad-'], [class*='_ad_'],\n    [id*='ad-'], [id*='-ad-'], [id*='_ad_'],\n    [class*='banner'], [id*='banner'],\n    [class*='advert'], [id*='advert'],\n    .advertisement, .advert, .ads,\n    .ad-container, .ad-slot, .ad-unit,\n    [data-ad-slot], [data-advertisement],\n    ins.adsbygoogle\n  `;\n\n  try {\n    const elements = document.querySelectorAll(adSelectors);\n    elements.forEach((el) => {\n      if (el && el.offsetHeight > 10 && el.offsetWidth > 10) {\n        el.style.display = \"none\";\n        el.style.visibility = \"hidden\";\n        el.style.opacity = \"0\";\n        blockedCount++;\n      }\n    });\n  } catch (e) {\n    console.error(\"[AdBlock Pro] Error blocking ads:\", e);\n  }\n\n  if (blockedCount > 0) {\n    console.log(\"[AdBlock Pro] Blocked\", blockedCount, \"ad elements\");\n  }\n}\n\nfunction blockTrackers() {\n  console.log(\"[AdBlock Pro] Blocking trackers...\");\n\n  const scripts = document.querySelectorAll(\"script\");\n  scripts.forEach((script) => {\n    if (!script.src) return;\n    const src = script.src.toLowerCase();\n\n    const isTracker =\n      src.includes(\"google-analytics\") ||\n      src.includes(\"analytics.google\") ||\n      src.includes(\"gtag\") ||\n      src.includes(\"facebook.com/tr\") ||\n      src.includes(\"segment.com\") ||\n      src.includes(\"mixpanel\") ||\n      src.includes(\"amplitude\") ||\n      src.includes(\"tracking\");\n\n    if (isTracker) {\n      script.remove();\n      notifyBlock(script.src, \"tracker\");\n      blockTracker.trackers++;\n    }\n  });\n\n  const images = document.querySelectorAll(\"img\");\n  images.forEach((img) => {\n    const src = (img.src || \"\").toLowerCase();\n    const isTracker = src.includes(\"facebook\") || src.includes(\"track\");\n\n    if (isTracker && (src.includes(\"1x1\") || img.width === 1 || img.height === 1)) {\n      img.style.display = \"none\";\n      blockTracker.trackers++;\n    }\n  });\n}\n\nfunction blockMiners() {\n  console.log(\"[AdBlock Pro] Blocking crypto miners...\");\n\n  const scripts = document.querySelectorAll(\"script\");\n  scripts.forEach((script) => {\n    if (!script.src) {\n      const content = script.textContent || script.innerHTML;\n      const hasSuspiciousCode = SUSPICIOUS_KEYWORDS.some(keyword => \n        content.includes(keyword)\n      );\n      \n      if (hasSuspiciousCode) {\n        console.log(\"[AdBlock Pro] Blocked suspicious miner script (inline)\");\n        script.remove();\n        notifyBlock(\"inline-miner-script\", \"miner\");\n        blockTracker.miners++;\n      }\n      return;\n    }\n\n    const src = script.src.toLowerCase();\n    const isMiner = MINER_SCRIPTS.some(miner => src.includes(miner));\n\n    if (isMiner) {\n      script.remove();\n      notifyBlock(script.src, \"miner\");\n      blockTracker.miners++;\n      console.log(\"[AdBlock Pro] Blocked crypto miner:\", script.src);\n    }\n  });\n}\n\nfunction blockCookieBanners() {\n  console.log(\"[AdBlock Pro] Blocking cookie banners...\");\n  let blockedCount = 0;\n\n  try {\n    const elements = document.querySelectorAll(COOKIE_BANNER_SELECTORS.join(', '));\n    \n    elements.forEach((el) => {\n      if (!el || el.offsetHeight < 30 || el.offsetWidth < 100) return;\n\n      const text = (el.textContent || '').toLowerCase();\n      const hasCookieKeyword = COOKIE_BANNER_KEYWORDS.some(keyword => text.includes(keyword));\n      \n      const hasMultipleButtons = el.querySelectorAll('button, a.button, [role=\"button\"]').length >= 2;\n      const hasAcceptButton = text.includes('accept') || text.includes('aceptar') || \n                               text.includes('agree') || text.includes('de acuerdo');\n      \n      if (hasCookieKeyword || (hasMultipleButtons && hasAcceptButton)) {\n        el.style.display = 'none';\n        el.style.visibility = 'hidden';\n        el.remove();\n        blockedCount++;\n      }\n    });\n\n    const overlays = document.querySelectorAll('[class*=\"overlay\"], [class*=\"backdrop\"], [class*=\"modal-backdrop\"]');\n    overlays.forEach((overlay) => {\n      if (overlay && overlay.style && overlay.style.zIndex && parseInt(overlay.style.zIndex) > 999) {\n        const text = (overlay.textContent || '').toLowerCase();\n        const hasCookieKeyword = COOKIE_BANNER_KEYWORDS.some(keyword => text.includes(keyword));\n        if (hasCookieKeyword) {\n          overlay.remove();\n          blockedCount++;\n        }\n      }\n    });\n\n    if (blockedCount > 0) {\n      document.body.style.overflow = '';\n      document.documentElement.style.overflow = '';\n      console.log(\"[AdBlock Pro] Blocked\", blockedCount, \"cookie banners\");\n    }\n  } catch (e) {\n    console.error(\"[AdBlock Pro] Error blocking cookie banners:\", e);\n  }\n}\n\nfunction blockYouTubeAds() {\n  console.log(\"[AdBlock Pro] Blocking YouTube ads...\");\n  let blockedCount = 0;\n\n  try {\n    const elements = document.querySelectorAll(YOUTUBE_AD_SELECTORS.join(', '));\n    \n    elements.forEach((el) => {\n      if (el) {\n        el.style.display = 'none';\n        el.style.visibility = 'hidden';\n        el.remove();\n        blockedCount++;\n      }\n    });\n\n    const adContainers = document.querySelectorAll('[id*=\"ad-\"], [id*=\"ads-\"]');\n    adContainers.forEach((container) => {\n      const text = (container.textContent || '').toLowerCase();\n      if (text.includes('advertisement') || text.includes('sponsored')) {\n        container.style.display = 'none';\n        container.remove();\n        blockedCount++;\n      }\n    });\n\n    const skipButton = document.querySelector('.ytp-ad-skip-button-container');\n    if (skipButton && skipButton.querySelector('.ytp-ad-skip-button')) {\n      skipButton.querySelector('.ytp-ad-skip-button').click();\n      console.log(\"[AdBlock Pro] Auto-clicked skip ad button\");\n    }\n\n    if (blockedCount > 0) {\n      console.log(\"[AdBlock Pro] Blocked\", blockedCount, \"YouTube ad elements\");\n      notifyBlock(\"youtube-ads\", \"ad\");\n    }\n  } catch (e) {\n    console.error(\"[AdBlock Pro] Error blocking YouTube ads:\", e);\n  }\n}\n\nfunction blockTwitchAds() {\n  console.log(\"[AdBlock Pro] Blocking Twitch ads...\");\n  let blockedCount = 0;\n\n  try {\n    const elements = document.querySelectorAll(TWITCH_AD_SELECTORS.join(', '));\n    \n    elements.forEach((el) => {\n      if (el) {\n        el.style.display = 'none';\n        el.style.visibility = 'hidden';\n        el.remove();\n        blockedCount++;\n      }\n    });\n\n    const adElements = document.querySelectorAll('[class*=\"Ad\"], [class*=\"-ad-\"], [data-test-selector*=\"commercial\"]');\n    adElements.forEach((el) => {\n      if (el && el.offsetHeight > 10) {\n        el.style.display = 'none';\n        el.remove();\n        blockedCount++;\n      }\n    });\n\n    if (blockedCount > 0) {\n      console.log(\"[AdBlock Pro] Blocked\", blockedCount, \"Twitch ad elements\");\n      notifyBlock(\"twitch-ads\", \"ad\");\n    }\n  } catch (e) {\n    console.error(\"[AdBlock Pro] Error blocking Twitch ads:\", e);\n  }\n}\n\nfunction observeDOMChanges() {\n  if (domObserver) {\n    domObserver.disconnect();\n  }\n\n  lastActivityTime = Date.now();\n\n  domObserver = new MutationObserver((mutations) => {\n    lastActivityTime = Date.now();\n\n    if (observerTimeout) {\n      clearTimeout(observerTimeout);\n    }\n\n    observerTimeout = setTimeout(() => {\n      let hasNewAds = false;\n      const processedNodes = new Set();\n      const hostname = window.location.hostname;\n\n      for (const mutation of mutations) {\n        if (mutation.type === \"childList\") {\n          mutation.addedNodes.forEach((node) => {\n            if (node.nodeType !== Node.ELEMENT_NODE || processedNodes.has(node)) return;\n            \n            processedNodes.add(node);\n\n            if (node.tagName === \"SCRIPT\" && node.src && isAdScript(node.src)) {\n              node.remove();\n              notifyBlock(node.src, \"ad\");\n              hasNewAds = true;\n            } else if (node.tagName === \"IFRAME\" && node.src && isAdScript(node.src)) {\n              node.remove();\n              notifyBlock(node.src, \"ad\");\n              hasNewAds = true;\n            } else if (node.classList && node.classList.length > 0) {\n              const classes = Array.from(node.classList);\n              const hasAdClass = classes.some((cls) => {\n                const lower = cls.toLowerCase();\n                return lower.includes(\"ad-\") || lower.includes(\"-ad\") || \n                       lower.includes(\"_ad_\") || lower === \"ad\" || \n                       lower.includes(\"advert\") || lower.includes(\"banner\");\n              });\n              \n              if (hasAdClass && node.offsetHeight > 10 && node.offsetWidth > 10) {\n                node.style.display = \"none\";\n                node.style.visibility = \"hidden\";\n                hasNewAds = true;\n              }\n            }\n\n            if (hostname.includes('youtube.com')) {\n              if (node.matches && YOUTUBE_AD_SELECTORS.some(selector => {\n                try { return node.matches(selector); } catch { return false; }\n              })) {\n                node.style.display = 'none';\n                node.remove();\n                hasNewAds = true;\n              }\n            } else if (hostname.includes('twitch.tv')) {\n              if (node.matches && TWITCH_AD_SELECTORS.some(selector => {\n                try { return node.matches(selector); } catch { return false; }\n              })) {\n                node.style.display = 'none';\n                node.remove();\n                hasNewAds = true;\n              }\n            }\n          });\n        }\n      }\n\n      if (hasNewAds) {\n        blockAds();\n        if (hostname.includes('youtube.com')) {\n          blockYouTubeAds();\n        } else if (hostname.includes('twitch.tv')) {\n          blockTwitchAds();\n        }\n      }\n    }, OBSERVER_DELAY);\n  });\n\n  domObserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n    attributes: false,\n    characterData: false\n  });\n\n  startIdleCheck();\n\n  console.log(\"[AdBlock Pro] Optimized DOM observer active\");\n}\n\nfunction startIdleCheck() {\n  if (idleCheckInterval) {\n    clearInterval(idleCheckInterval);\n  }\n\n  idleCheckInterval = setInterval(() => {\n    const timeSinceLastActivity = Date.now() - lastActivityTime;\n    \n    if (timeSinceLastActivity > IDLE_TIMEOUT) {\n      if (domObserver) {\n        domObserver.disconnect();\n        console.log(\"[AdBlock Pro] DOM observer paused due to inactivity\");\n      }\n      \n      if (idleCheckInterval) {\n        clearInterval(idleCheckInterval);\n        idleCheckInterval = null;\n      }\n\n      document.addEventListener(\"scroll\", resumeObserver, { once: true, passive: true });\n      document.addEventListener(\"click\", resumeObserver, { once: true, passive: true });\n      document.addEventListener(\"mousemove\", resumeObserver, { once: true, passive: true });\n    }\n  }, 10000);\n}\n\nfunction resumeObserver() {\n  if (!domObserver || !domObserver.takeRecords) {\n    observeDOMChanges();\n    console.log(\"[AdBlock Pro] DOM observer resumed\");\n  }\n}\n\nfunction performMLScan() {\n  if (!mlDetector) return;\n  \n  const detections = mlDetector.scanPage();\n  \n  detections.forEach(detection => {\n    if (detection.visual.confidence > 0.7 || detection.behavioral.isSuspicious) {\n      hideElement(detection.element, 'ML-detected ad');\n      blockTracker.mlDetections++;\n      \n      notifyBlock(\n        detection.element.src || detection.element.href || window.location.href,\n        'ml-detection'\n      );\n    }\n  });\n  \n  if (detections.length > 0) {\n    console.log(`[AdBlock Pro] ML scan: ${detections.length} detections, ${blockTracker.mlDetections} blocked`);\n  }\n}\n\nfunction isAdScript(url) {\n  const lower = url.toLowerCase();\n  \n  // Check with ML detector for CNAME cloaking\n  if (mlDetector) {\n    const networkAnalysis = mlDetector.analyzeNetworkRequest(url);\n    if (networkAnalysis.isCloaked) {\n      console.log('[AdBlock Pro] CNAME cloaking detected:', url);\n      return true;\n    }\n  }\n  \n  return (\n    lower.includes(\"doubleclick\") ||\n    lower.includes(\"pagead\") ||\n    lower.includes(\"googleads\") ||\n    lower.includes(\"amazon-adsystem\") ||\n    lower.includes(\"taboola\") ||\n    lower.includes(\"outbrain\")\n  );\n}\n\nfunction notifyBlock(url, type) {\n  chrome.runtime.sendMessage(\n    {\n      action: \"blockAd\",\n      url: url,\n      type: type,\n    },\n    (response) => {\n      if (chrome.runtime.lastError) {\n        console.error(\"[AdBlock Pro] Error sending message:\", chrome.runtime.lastError.message);\n        return;\n      }\n      if (response && response.success) {\n        console.log(\"[AdBlock Pro] Notified background of block:\", url);\n      }\n    }\n  );\n}\n\nchrome.storage.onChanged.addListener((changes) => {\n  if (changes.isEnabled) {\n    console.log(\"[AdBlock Pro] Extension toggled, reloading page\");\n    if (domObserver) {\n      domObserver.disconnect();\n    }\n    location.reload();\n  }\n});\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message.action === \"blockingLevelChanged\") {\n    console.log(\"[AdBlock Pro] Blocking level changed to:\", message.level);\n    location.reload();\n  } else if (message.action === \"antiDetectionChanged\") {\n    console.log(\"[AdBlock Pro] Anti-detection changed to:\", message.enabled);\n    location.reload();\n  }\n});\n\n// Periodic ML scan (every 5 seconds)\nif (mlDetector) {\n  setInterval(() => {\n    performMLScan();\n  }, 5000);\n  \n  // Initial scan after page load\n  setTimeout(() => {\n    performMLScan();\n  }, 2000);\n}\n","size_bytes":19983},"config.js":{"content":"const BLOCKING_LEVELS = {\n  BASIC: 'basic',\n  ADVANCED: 'advanced',\n  AGGRESSIVE: 'aggressive'\n};\n\nconst DEFAULT_CONFIG = {\n  blockingLevel: BLOCKING_LEVELS.ADVANCED,\n  antiDetection: true,\n  blockYouTube: true,\n  blockTwitch: true,\n  blockTrackers: true,\n  blockMiners: true,\n  blockCookieBanners: true,\n  enableLogging: false\n};\n\nconst LEVEL_FEATURES = {\n  [BLOCKING_LEVELS.BASIC]: {\n    networkRules: true,\n    basicDomCleanup: true,\n    youtubeBasic: false,\n    twitchBasic: false,\n    antiDetection: false,\n    aggressiveMutation: false,\n    cosmeticFiltering: false\n  },\n  [BLOCKING_LEVELS.ADVANCED]: {\n    networkRules: true,\n    basicDomCleanup: true,\n    youtubeBasic: true,\n    twitchBasic: true,\n    antiDetection: true,\n    aggressiveMutation: false,\n    cosmeticFiltering: true\n  },\n  [BLOCKING_LEVELS.AGGRESSIVE]: {\n    networkRules: true,\n    basicDomCleanup: true,\n    youtubeBasic: true,\n    twitchBasic: true,\n    antiDetection: true,\n    aggressiveMutation: true,\n    cosmeticFiltering: true\n  }\n};\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = { BLOCKING_LEVELS, DEFAULT_CONFIG, LEVEL_FEATURES };\n}\n","size_bytes":1148},"injected-script.js":{"content":";(() => {\n  console.log(\"[AdBlock Pro] Injected protection script initializing...\");\n\n  let currentLevel = 'advanced';\n  let antiDetectionEnabled = true;\n  let malwareDetected = 0;\n  let minersDetected = 0;\n  let suspiciousActivities = [];\n\n  window.addEventListener('message', (event) => {\n    if (event.source !== window) return;\n    if (event.data.type === 'ADBLOCK_PRO_CONFIG') {\n      currentLevel = event.data.config.blockingLevel || 'advanced';\n      antiDetectionEnabled = event.data.config.antiDetection !== false;\n      console.log(\"[AdBlock Pro] Config received - Level:\", currentLevel, \"Anti-detection:\", antiDetectionEnabled);\n    }\n  });\n\n  window.adsbygoogle = window.adsbygoogle || [];\n  window.adsbygoogle.push = () => {\n    if (currentLevel !== 'basic') {\n      console.log(\"[AdBlock Pro] Blocked adsbygoogle.push()\");\n    }\n    return;\n  };\n\n  window.ga = () => {};\n  window.gtag = () => {};\n  window.fbq = () => {};\n  window._gaq = [];\n  window.dataLayer = window.dataLayer || [];\n\n  window.analytics = {\n    track: () => {},\n    page: () => {},\n    identify: () => {},\n  };\n\n  const CRYPTO_MINER_OBJECTS = [\n    'CoinHive', 'CRLT', 'JSEcoin', 'Miner', 'EtherMiner', 'Client',\n    'CoinImp', 'Minr', 'CryptoLoot', 'WebMiner', 'DeepMiner'\n  ];\n\n  CRYPTO_MINER_OBJECTS.forEach(obj => {\n    Object.defineProperty(window, obj, {\n      get: function() {\n        console.log(`[AdBlock Pro] Blocked crypto miner object: ${obj}`);\n        minersDetected++;\n        reportThreat('miner', `Blocked miner object: ${obj}`);\n        return undefined;\n      },\n      set: function() {},\n      configurable: false\n    });\n  });\n\n  const blockedDomains = [\n    \"doubleclick\", \"pagead\", \"googleads\", \"adsbygoogle\",\n    \"facebook.com/tr\", \"analytics.google\", \"google-analytics\",\n    \"segment.com\", \"mixpanel.com\", \"taboola.com\", \"outbrain.com\",\n    \"amazon-adsystem.com\", \"googlesyndication.com\", \"googleadservices.com\",\n    \"coinhive.com\", \"coin-hive.com\", \"crypto-loot.com\", \"jsecoin.com\",\n    \"webminepool.com\", \"monerominer.rocks\", \"cryptaloot.pro\",\n    \"deepminer.net\", \"authedmine.com\", \"minemytraffic.com\",\n    \"coinimp.com\", \"minr.pw\", \"statdynamic.com\", \"ad-miner.com\",\n    \"ppoi.org\", \"webmine.cz\", \"coinerra.com\", \"mineralt.io\"\n  ];\n\n  const MALWARE_PATTERNS = [\n    'eval\\\\s*\\\\(\\\\s*atob\\\\s*\\\\(',\n    'document\\\\.write\\\\s*\\\\(\\\\s*unescape\\\\s*\\\\(',\n    'fromCharCode\\\\s*\\\\.\\\\s*apply',\n    'location\\\\.replace',\n    'XMLHttpRequest.*onload.*eval'\n  ];\n\n  const MINER_WASM_SIGNATURES = [\n    'cryptonight', 'monero', 'xmr', 'minero', 'hashrate',\n    'argon2', 'scrypt', 'keccak', 'blake2b'\n  ];\n\n  function reportThreat(type, details) {\n    suspiciousActivities.push({\n      type,\n      details,\n      timestamp: Date.now(),\n      url: window.location.href\n    });\n    \n    try {\n      window.postMessage({\n        type: 'ADBLOCK_PRO_THREAT',\n        threat: { type, details, url: window.location.href, timestamp: Date.now() }\n      }, '*');\n    } catch (e) {\n      console.warn(\"[AdBlock Pro] Failed to report threat:\", e);\n    }\n  }\n\n  function isBlockedUrl(url) {\n    if (!url) return false;\n    const urlString = typeof url === \"string\" ? url : url.toString();\n    return blockedDomains.some((domain) => urlString.toLowerCase().includes(domain));\n  }\n\n  function isSuspiciousScript(code) {\n    if (!code || typeof code !== 'string') return false;\n    \n    let suspicionScore = 0;\n    const detectedPatterns = [];\n    \n    MALWARE_PATTERNS.forEach(patternStr => {\n      const pattern = new RegExp(patternStr, 'i');\n      if (pattern.test(code)) {\n        suspicionScore += 2;\n        detectedPatterns.push(patternStr);\n      }\n    });\n    \n    if (code.includes('crypto') && code.includes('hash')) {\n      suspicionScore += 3;\n      detectedPatterns.push('crypto+hash');\n    }\n    if (code.includes('WebAssembly') && code.includes('instantiate') && code.includes('monero')) {\n      suspicionScore += 4;\n      detectedPatterns.push('wasm+monero');\n    }\n    if (code.length > 50000 && code.split('\\n').length < 10) {\n      suspicionScore += 2;\n      detectedPatterns.push('minified-large');\n    }\n    \n    const base64Matches = code.match(/[A-Za-z0-9+\\/]{200,}/g);\n    if (base64Matches && base64Matches.length > 3) {\n      suspicionScore += 2;\n      detectedPatterns.push('base64-encoded');\n    }\n    \n    if (suspicionScore >= 5) {\n      console.warn(\"[AdBlock Pro] Suspicious script detected! Score:\", suspicionScore, \"Patterns:\", detectedPatterns);\n      malwareDetected++;\n      reportThreat('malware', `Suspicious script (score: ${suspicionScore}, patterns: ${detectedPatterns.join(', ')})`);\n      return true;\n    }\n    \n    return false;\n  }\n\n  function analyzeWasmModule(buffer) {\n    if (!buffer || !buffer.byteLength) return { suspicious: false, score: 0 };\n    \n    let score = 0;\n    const indicators = [];\n    \n    try {\n      const view = new Uint8Array(buffer.slice(0, Math.min(20000, buffer.byteLength)));\n      const text = String.fromCharCode.apply(null, view);\n      \n      MINER_WASM_SIGNATURES.forEach(sig => {\n        if (text.toLowerCase().includes(sig)) {\n          score += 4;\n          indicators.push(sig);\n        }\n      });\n      \n      if (buffer.byteLength > 2000000) {\n        score += 1;\n        indicators.push('large-size');\n      }\n      \n      if (text.includes('worker') && text.includes('hash')) {\n        score += 3;\n        indicators.push('worker+hash');\n      }\n      \n      const suspiciousImports = ['thread', 'atomic', 'memory.grow'];\n      suspiciousImports.forEach(imp => {\n        if (text.includes(imp)) {\n          score += 1;\n          indicators.push(imp);\n        }\n      });\n      \n    } catch (e) {\n      console.warn(\"[AdBlock Pro] Error analyzing WASM module:\", e);\n    }\n    \n    return { suspicious: score >= 8, score, indicators };\n  }\n\n  let cpuMonitoringInterval = null;\n  let lastCPUCheck = Date.now();\n  \n  function startCPUMonitoring() {\n    if (currentLevel === 'basic') return;\n    \n    if (cpuMonitoringInterval) clearInterval(cpuMonitoringInterval);\n    \n    cpuMonitoringInterval = setInterval(() => {\n      const now = Date.now();\n      const timeDiff = now - lastCPUCheck;\n      \n      if (timeDiff < 5000) return;\n      \n      lastCPUCheck = now;\n      \n      if (performance && performance.memory) {\n        const usedMemory = performance.memory.usedJSHeapSize;\n        const totalMemory = performance.memory.totalJSHeapSize;\n        const memoryUsagePercent = (usedMemory / totalMemory) * 100;\n        \n        if (memoryUsagePercent > 90 && currentLevel === 'aggressive') {\n          console.warn(\"[AdBlock Pro] High memory usage detected - potential miner activity\");\n          reportThreat('resource-abuse', `High memory usage: ${memoryUsagePercent.toFixed(1)}%`);\n        }\n      }\n    }, 10000);\n  }\n\n  const originalFetch = window.fetch;\n  window.fetch = function (...args) {\n    const url = args[0];\n    if (typeof url === \"string\" || url instanceof URL || url instanceof Request) {\n      const urlToCheck = url instanceof Request ? url.url : url;\n      if (isBlockedUrl(urlToCheck)) {\n        console.log(\"[AdBlock Pro] Blocked fetch to:\", urlToCheck);\n        return Promise.reject(new Error(\"Blocked by AdBlock Pro\"));\n      }\n    }\n    return originalFetch.apply(this, args);\n  };\n\n  if (antiDetectionEnabled) {\n    Object.defineProperty(window.fetch, 'toString', {\n      value: () => 'function fetch() { [native code] }',\n      configurable: false\n    });\n  }\n\n  const originalOpen = XMLHttpRequest.prototype.open;\n  XMLHttpRequest.prototype.open = function (method, url, ...rest) {\n    if (isBlockedUrl(url)) {\n      console.log(\"[AdBlock Pro] Blocked XMLHttpRequest to:\", url);\n      this.addEventListener(\"readystatechange\", function () {\n        if (this.readyState === 4) {\n          Object.defineProperty(this, \"status\", { value: 0 });\n          Object.defineProperty(this, \"responseText\", { value: \"\" });\n        }\n      });\n      return;\n    }\n    return originalOpen.apply(this, [method, url, ...rest]);\n  };\n\n  if (antiDetectionEnabled) {\n    Object.defineProperty(XMLHttpRequest.prototype.open, 'toString', {\n      value: () => 'function open() { [native code] }',\n      configurable: false\n    });\n  }\n\n  const originalEval = window.eval;\n  window.eval = function(code) {\n    if (currentLevel !== 'basic' && isSuspiciousScript(code)) {\n      console.warn(\"[AdBlock Pro] Blocked suspicious eval()\");\n      return null;\n    }\n    return originalEval.apply(this, arguments);\n  };\n\n  const originalWindowOpen = window.open;\n  window.open = function (url, ...args) {\n    if (url && isBlockedUrl(url)) {\n      console.log(\"[AdBlock Pro] Blocked popup to:\", url);\n      return null;\n    }\n    if (!args[0] && url) {\n      console.log(\"[AdBlock Pro] Blocked suspicious popup\");\n      return null;\n    }\n    return originalWindowOpen.apply(this, [url, ...args]);\n  };\n\n  const originalWebSocket = window.WebSocket;\n  window.WebSocket = function(url, protocols) {\n    if (isBlockedUrl(url)) {\n      console.log(\"[AdBlock Pro] Blocked WebSocket connection to:\", url);\n      reportThreat('tracker', `Blocked WebSocket to: ${url}`);\n      throw new Error(\"Blocked by AdBlock Pro\");\n    }\n    return new originalWebSocket(url, protocols);\n  };\n\n  if (typeof WebAssembly !== 'undefined' && currentLevel === 'aggressive') {\n    const originalWasmInstantiate = WebAssembly.instantiate;\n    WebAssembly.instantiate = function(...args) {\n      const bufferOrModule = args[0];\n      \n      if (bufferOrModule && bufferOrModule.byteLength) {\n        const analysis = analyzeWasmModule(bufferOrModule);\n        \n        if (analysis.suspicious) {\n          console.warn(\"[AdBlock Pro] Blocked suspected crypto-mining WebAssembly module\");\n          console.warn(\"[AdBlock Pro] Suspicion score:\", analysis.score, \"Indicators:\", analysis.indicators);\n          minersDetected++;\n          reportThreat('miner', `Blocked WASM module (score: ${analysis.score}, indicators: ${analysis.indicators.join(', ')})`);\n          return Promise.reject(new Error(\"Blocked by AdBlock Pro\"));\n        } else if (analysis.score > 0) {\n          console.log(\"[AdBlock Pro] WASM module passed (score:\", analysis.score, \")\");\n        }\n      }\n      \n      return originalWasmInstantiate.apply(this, args);\n    };\n  }\n\n  function blockYouTubeAds() {\n    if (currentLevel === 'basic') return;\n    if (!window.location.hostname.includes('youtube.com')) return;\n    \n    console.log(\"[AdBlock Pro] Initializing enhanced YouTube ad blocker...\");\n\n    const AD_RENDERER_KEYS = [\n      'adSlotRenderer',\n      'adPlacementRenderer',\n      'promotedSparklesWebRenderer',\n      'displayAdRenderer',\n      'actionCompanionAdRenderer',\n      'linearAdRenderer',\n      'adBreakServiceRenderer',\n      'playerAds',\n      'adPlacements',\n      'adSlots'\n    ];\n\n    const originalParse = JSON.parse;\n    JSON.parse = function(...args) {\n      const result = originalParse.apply(this, args);\n      \n      if (result && typeof result === 'object') {\n        if (result.playerResponse) {\n          AD_RENDERER_KEYS.forEach(key => {\n            if (result.playerResponse[key]) delete result.playerResponse[key];\n          });\n        }\n        \n        AD_RENDERER_KEYS.forEach(key => {\n          if (result[key]) delete result[key];\n        });\n      }\n      \n      return result;\n    };\n\n    if (window.ytInitialPlayerResponse) {\n      AD_RENDERER_KEYS.forEach(key => {\n        if (window.ytInitialPlayerResponse[key]) {\n          delete window.ytInitialPlayerResponse[key];\n        }\n      });\n    }\n\n    if (window.ytInitialData && currentLevel !== 'basic') {\n      const removeAdsFromObject = (obj) => {\n        if (!obj || typeof obj !== 'object') return;\n        \n        AD_RENDERER_KEYS.forEach(key => {\n          if (obj[key]) delete obj[key];\n        });\n        \n        for (let key in obj) {\n          if (typeof obj[key] === 'object') {\n            removeAdsFromObject(obj[key]);\n          }\n        }\n      };\n      removeAdsFromObject(window.ytInitialData);\n    }\n\n    if (window.yt && window.yt.config_) {\n      if (window.yt.config_.EXPERIMENT_FLAGS) {\n        window.yt.config_.EXPERIMENT_FLAGS.web_player_ads_control = false;\n        window.yt.config_.EXPERIMENT_FLAGS.web_player_show_skippable_ads = false;\n        window.yt.config_.EXPERIMENT_FLAGS.disable_child_node_auto_formatted_strings = true;\n      }\n    }\n\n    const playerCheckInterval = setInterval(() => {\n      const skipButton = document.querySelector('.ytp-ad-skip-button, .ytp-ad-skip-button-modern, .ytp-skip-ad-button');\n      if (skipButton && skipButton.offsetParent !== null) {\n        skipButton.click();\n        console.log(\"[AdBlock Pro] Clicked YouTube skip button\");\n      }\n      \n      const videoAd = document.querySelector('.video-ads, .ytp-ad-player-overlay');\n      if (videoAd) {\n        const video = document.querySelector('video');\n        if (video && video.duration) {\n          video.currentTime = video.duration;\n          console.log(\"[AdBlock Pro] Skipped to end of ad\");\n        }\n      }\n      \n      const shortsAd = document.querySelector('ytd-reel-video-renderer[is-ad]');\n      if (shortsAd) {\n        shortsAd.remove();\n        console.log(\"[AdBlock Pro] Removed Shorts ad\");\n      }\n    }, 500);\n\n    setTimeout(() => clearInterval(playerCheckInterval), 120000);\n  }\n\n  function blockTwitchAds() {\n    if (currentLevel === 'basic') return;\n    if (!window.location.hostname.includes('twitch.tv')) return;\n    \n    console.log(\"[AdBlock Pro] Initializing enhanced Twitch ad blocker...\");\n\n    Object.defineProperty(window, 'twads', {\n      get: () => undefined,\n      set: () => {},\n      configurable: false\n    });\n\n    Object.defineProperty(window, 'adRequest', {\n      get: () => undefined,\n      set: () => {},\n      configurable: false\n    });\n\n    Object.defineProperty(window, 'Twitch', {\n      get: () => {\n        return {\n          ads: {\n            commercial: () => {},\n            disable: () => {}\n          }\n        };\n      },\n      configurable: false\n    });\n\n    const twitchAdKeywords = [\n      'amazon-adsystem', 'twitchads', 'adswizzads', 'advertising',\n      'commercial_break', 'preroll', 'midroll', 'ad-podding', 'ad_break',\n      'adm_', 'adsManager', 'videoAdUI'\n    ];\n\n    const TWITCH_AD_GQL_FIELDS = [\n      'adBreak',\n      'prerollAd',\n      'midrollAd',\n      'commercialBreak',\n      'adPodding',\n      'adSchedule'\n    ];\n\n    const originalFetchTwitch = window.fetch;\n    window.fetch = function(...args) {\n      const url = args[0];\n      const urlStr = typeof url === 'string' ? url : (url?.url || '');\n      \n      if (twitchAdKeywords.some(keyword => urlStr.toLowerCase().includes(keyword))) {\n        console.log(\"[AdBlock Pro] Blocked Twitch ad request:\", urlStr);\n        return Promise.reject(new Error(\"Blocked by AdBlock Pro\"));\n      }\n      \n      if (urlStr.includes('.m3u8') || urlStr.includes('/playlist.m3u8')) {\n        return originalFetchTwitch.apply(this, args).then(async response => {\n          const text = await response.text();\n          \n          const hasAdMarkers = text.includes('#EXT-X-DATERANGE') || \n                               text.includes('stitched-ad') ||\n                               text.includes('Amazon-Ad');\n          \n          if (hasAdMarkers) {\n            console.log(\"[AdBlock Pro] Detected ad markers in stream, filtering...\");\n            const lines = text.split('\\n');\n            const cleanedLines = [];\n            let skipNext = false;\n            \n            for (let i = 0; i < lines.length; i++) {\n              const line = lines[i];\n              \n              if (line.includes('stitched-ad') || line.includes('Amazon-Ad') || line.includes('#EXT-X-DATERANGE')) {\n                skipNext = true;\n                continue;\n              }\n              \n              if (skipNext && (line.startsWith('http') || line.startsWith('#EXTINF'))) {\n                skipNext = false;\n                continue;\n              }\n              \n              cleanedLines.push(line);\n            }\n            \n            return new Response(cleanedLines.join('\\n'), {\n              status: response.status,\n              statusText: response.statusText,\n              headers: response.headers\n            });\n          }\n          \n          return new Response(text, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers\n          });\n        });\n      }\n      \n      if (urlStr.includes('gql') || urlStr.includes('graphql')) {\n        return originalFetchTwitch.apply(this, args).then(async response => {\n          const clonedResponse = response.clone();\n          \n          try {\n            const data = await clonedResponse.json();\n            \n            if (data && typeof data === 'object') {\n              const removeAdsFromGQL = (obj) => {\n                if (!obj || typeof obj !== 'object') return obj;\n                \n                if (Array.isArray(obj)) {\n                  return obj.map(removeAdsFromGQL);\n                }\n                \n                const cleaned = {};\n                for (let key in obj) {\n                  if (TWITCH_AD_GQL_FIELDS.includes(key)) {\n                    continue;\n                  }\n                  cleaned[key] = removeAdsFromGQL(obj[key]);\n                }\n                return cleaned;\n              };\n              \n              const filtered = removeAdsFromGQL(data);\n              \n              return new Response(JSON.stringify(filtered), {\n                status: response.status,\n                statusText: response.statusText,\n                headers: response.headers\n              });\n            }\n          } catch (e) {\n            console.log(\"[AdBlock Pro] Could not parse GQL response\");\n          }\n          \n          return response;\n        });\n      }\n      \n      return originalFetchTwitch.apply(this, args);\n    };\n\n    setInterval(() => {\n      const purpleScreen = document.querySelector('[data-a-target=\"video-ad-countdown\"]');\n      if (purpleScreen) {\n        purpleScreen.remove();\n        console.log(\"[AdBlock Pro] Removed purple ad screen\");\n      }\n      \n      const adBanner = document.querySelectorAll('.top-nav__menu, .carousel-ad, [class*=\"commercial\"]');\n      adBanner.forEach(el => {\n        if (el && el.offsetParent !== null) {\n          el.remove();\n          console.log(\"[AdBlock Pro] Removed Twitch ad element\");\n        }\n      });\n    }, 1000);\n  }\n\n  if (antiDetectionEnabled) {\n    const addRandomJitter = () => Math.floor(Math.random() * 50);\n    setTimeout(() => {\n      blockYouTubeAds();\n      blockTwitchAds();\n      startCPUMonitoring();\n    }, 50 + addRandomJitter());\n  } else {\n    blockYouTubeAds();\n    blockTwitchAds();\n    startCPUMonitoring();\n  }\n\n  setInterval(() => {\n    if (malwareDetected > 0 || minersDetected > 0) {\n      console.log(`[AdBlock Pro] Threats detected - Malware: ${malwareDetected}, Miners: ${minersDetected}`);\n    }\n  }, 30000);\n\n  console.log(\"[AdBlock Pro] Enhanced protection script loaded successfully\");\n})();\n","size_bytes":19129},"extension-helper.js":{"content":"#!/usr/bin/env node\n\nconsole.log('\\n' + '='.repeat(70));\nconsole.log('  üõ°Ô∏è  AdBlock Pro v3.0.0 - Extensi√≥n de Navegador');\nconsole.log('='.repeat(70) + '\\n');\n\nconsole.log('üì¶ ESTADO: Extensi√≥n lista para instalar\\n');\n\nconsole.log('üìã INSTRUCCIONES DE INSTALACI√ìN:\\n');\nconsole.log('  1. Abre tu navegador (Chrome/Brave/Edge)');\nconsole.log('  2. Ve a: chrome://extensions/ (o brave://extensions/)');\nconsole.log('  3. Activa \"Modo de desarrollador\" (esquina superior derecha)');\nconsole.log('  4. Haz clic en \"Cargar extensi√≥n sin empaquetar\"');\nconsole.log('  5. Selecciona esta carpeta del proyecto');\nconsole.log('  6. ¬°La extensi√≥n se instalar√° autom√°ticamente!\\n');\n\nconsole.log('‚ú® CARACTER√çSTICAS IMPLEMENTADAS:\\n');\nconsole.log('  ‚úÖ Bloqueo agresivo de anuncios (8 listas de filtros)');\nconsole.log('  ‚úÖ Detecci√≥n ML de anuncios multi-capa');\nconsole.log('  ‚úÖ Bloqueo especializado YouTube/Twitch');\nconsole.log('  ‚úÖ Anti-fingerprinting (Canvas, WebGL, Audio, etc.)');\nconsole.log('  ‚úÖ Protecci√≥n contra malware con notificaciones');\nconsole.log('  ‚úÖ Selector de elementos (Ctrl+Shift+X)');\nconsole.log('  ‚úÖ Estad√≠sticas detalladas por dominio');\nconsole.log('  ‚úÖ UI oscura elegante minimalista');\nconsole.log('  ‚úÖ Manifest V3 compatible\\n');\n\nconsole.log('üéØ CONTROLES PRINCIPALES:\\n');\nconsole.log('  ‚Ä¢ Popup: Click en el icono de extensi√≥n');\nconsole.log('  ‚Ä¢ Toggle protecci√≥n: Interruptor en header del popup');\nconsole.log('  ‚Ä¢ Selector visual: Bot√≥n \"Selector\" o Ctrl+Shift+X');\nconsole.log('  ‚Ä¢ Navegaci√≥n: 5 pesta√±as (Resumen, Estad√≠sticas, Listas, Privacidad, Ajustes)\\n');\n\nconsole.log('üìÅ ESTRUCTURA DEL PROYECTO:\\n');\nconsole.log('  lib/               ‚Üí M√≥dulos de biblioteca (7 archivos)');\nconsole.log('  background.js      ‚Üí Service worker MV3');\nconsole.log('  content-script.js  ‚Üí Script inyectado en p√°ginas');\nconsole.log('  popup.html/js      ‚Üí Interfaz de usuario');\nconsole.log('  manifest.json      ‚Üí Configuraci√≥n de extensi√≥n\\n');\n\nconsole.log('üîß TESTING:\\n');\nconsole.log('  ‚Ä¢ Navega a cualquier sitio web con anuncios');\nconsole.log('  ‚Ä¢ Abre el popup para ver estad√≠sticas');\nconsole.log('  ‚Ä¢ Prueba el selector de elementos (Ctrl+Shift+X)');\nconsole.log('  ‚Ä¢ Verifica notificaciones al bloquear malware\\n');\n\nconsole.log('='.repeat(70));\nconsole.log('  Esta extensi√≥n NO requiere servidor - se carga en el navegador');\nconsole.log('='.repeat(70) + '\\n');\n\nsetInterval(() => {\n  process.stdout.write('.');\n}, 5000);\n","size_bytes":2540},"validate-extension.js":{"content":"#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\n\nconsole.log('\\nüõ°Ô∏è  AdBlock Pro - Extension Validator\\n');\nconsole.log('=' .repeat(50));\n\nconst requiredFiles = [\n  'manifest.json',\n  'background.js',\n  'content-script.js',\n  'injected-script.js',\n  'popup.html',\n  'popup.js',\n  'rules.json',\n  'config.js'\n];\n\nlet allValid = true;\n\nrequiredFiles.forEach(file => {\n  const exists = fs.existsSync(path.join(__dirname, file));\n  const status = exists ? '‚úÖ' : '‚ùå';\n  console.log(`${status} ${file}`);\n  if (!exists) allValid = false;\n});\n\nconsole.log('=' .repeat(50));\n\nif (allValid) {\n  console.log('‚úÖ All extension files present');\n  console.log('\\nüì¶ Extension ready for testing in Brave/Chrome');\n  console.log('\\nüìñ To install:');\n  console.log('  1. Open brave://extensions or chrome://extensions');\n  console.log('  2. Enable \"Developer mode\"');\n  console.log('  3. Click \"Load unpacked\"');\n  console.log('  4. Select this directory');\n  console.log('\\nüéØ Features:');\n  console.log('  ‚Ä¢ Multi-level blocking (Basic/Advanced/Aggressive)');\n  console.log('  ‚Ä¢ YouTube & Twitch ad blocking');\n  console.log('  ‚Ä¢ Tracker & miner protection');\n  console.log('  ‚Ä¢ Anti-detection system');\n  console.log('\\n‚ú® Extension is validated and ready!\\n');\n} else {\n  console.log('‚ùå Some extension files are missing');\n  process.exit(1);\n}\n","size_bytes":1387},"video-stream-detector.js":{"content":"// Advanced Video Stream Ad Detection Module\n// Detects ads embedded directly in video streams (YouTube, Twitch, etc.)\n\nclass VideoStreamDetector {\n  constructor() {\n    this.monitoredVideos = new WeakSet();\n    this.adDetections = 0;\n    this.streamAnalysis = {\n      bitrateChanges: [],\n      qualitySwitches: [],\n      streamInterruptions: []\n    };\n  }\n\n  // Monitor all video elements on the page\n  monitorVideos() {\n    const videos = document.querySelectorAll('video');\n    \n    videos.forEach(video => {\n      if (!this.monitoredVideos.has(video)) {\n        this.monitoredVideos.add(video);\n        this.attachVideoListeners(video);\n      }\n    });\n  }\n\n  // Attach listeners to video element\n  attachVideoListeners(video) {\n    // Monitor playback rate changes (ads often force 1x speed)\n    let lastPlaybackRate = video.playbackRate;\n    \n    const checkPlaybackRate = () => {\n      if (video.playbackRate !== lastPlaybackRate) {\n        if (video.playbackRate === 1 && lastPlaybackRate !== 1) {\n          console.log('[AdBlock Pro] Suspicious playback rate reset detected');\n        }\n        lastPlaybackRate = video.playbackRate;\n      }\n    };\n\n    // Monitor volume changes (ads sometimes boost volume)\n    let lastVolume = video.volume;\n    \n    const checkVolume = () => {\n      if (video.volume !== lastVolume) {\n        const volumeChange = Math.abs(video.volume - lastVolume);\n        if (volumeChange > 0.3) {\n          console.log('[AdBlock Pro] Suspicious volume change detected:', volumeChange);\n        }\n        lastVolume = video.volume;\n      }\n    };\n\n    // Monitor for ad markers in video timeline\n    video.addEventListener('timeupdate', () => {\n      checkPlaybackRate();\n      checkVolume();\n      \n      // Check if we're in an ad segment (YouTube specific)\n      if (window.location.hostname.includes('youtube.com')) {\n        this.detectYouTubeAdSegment(video);\n      }\n      \n      // Check for Twitch ad segments\n      if (window.location.hostname.includes('twitch.tv')) {\n        this.detectTwitchAdSegment(video);\n      }\n    });\n\n    // Monitor stream quality changes\n    video.addEventListener('loadedmetadata', () => {\n      this.analyzeStreamQuality(video);\n    });\n\n    // Monitor for waiting events (buffering during ads)\n    video.addEventListener('waiting', () => {\n      this.streamAnalysis.streamInterruptions.push({\n        time: video.currentTime,\n        timestamp: Date.now()\n      });\n    });\n  }\n\n  // Detect YouTube ad segments\n  detectYouTubeAdSegment(video) {\n    try {\n      // Check if player is showing ad UI\n      const adContainer = document.querySelector('.ytp-ad-player-overlay');\n      const adBadge = document.querySelector('.ytp-ad-simple-ad-badge');\n      const skipButton = document.querySelector('.ytp-ad-skip-button');\n      \n      if (adContainer || adBadge) {\n        console.log('[AdBlock Pro] YouTube ad UI detected, attempting skip');\n        this.adDetections++;\n        \n        // Try to skip\n        if (skipButton && !skipButton.disabled) {\n          skipButton.click();\n          console.log('[AdBlock Pro] Ad skip button clicked');\n        }\n        \n        // Try to seek past ad\n        const adDuration = this.estimateAdDuration(video);\n        if (adDuration && adDuration < 30) {\n          video.currentTime = video.currentTime + adDuration + 0.5;\n        }\n        \n        return true;\n      }\n      \n      // Check for ad module in player\n      const playerModule = document.querySelector('.ytp-ad-module');\n      if (playerModule && playerModule.style.display !== 'none') {\n        console.log('[AdBlock Pro] YouTube ad module active');\n        this.adDetections++;\n        return true;\n      }\n      \n    } catch (e) {\n      console.warn('[AdBlock Pro] Error detecting YouTube ad segment:', e);\n    }\n    \n    return false;\n  }\n\n  // Detect Twitch ad segments\n  detectTwitchAdSegment(video) {\n    try {\n      // Check for purple screen (Twitch ad placeholder)\n      const purpleScreen = document.querySelector('[data-a-target=\"video-ad-label\"]');\n      const adCountdown = document.querySelector('.tw-ad-countdown');\n      \n      if (purpleScreen || adCountdown) {\n        console.log('[AdBlock Pro] Twitch ad detected');\n        this.adDetections++;\n        \n        // Mute during ad\n        if (!video.muted) {\n          video.muted = true;\n          video.volume = 0;\n          \n          // Unmute after ad\n          setTimeout(() => {\n            video.muted = false;\n            video.volume = 1;\n          }, 5000);\n        }\n        \n        return true;\n      }\n      \n    } catch (e) {\n      console.warn('[AdBlock Pro] Error detecting Twitch ad segment:', e);\n    }\n    \n    return false;\n  }\n\n  // Estimate ad duration based on common lengths\n  estimateAdDuration(video) {\n    const commonAdDurations = [5, 6, 15, 20, 30];\n    \n    // Check video element properties\n    if (video.duration && video.duration < 35) {\n      // Likely a short ad\n      return Math.ceil(video.duration);\n    }\n    \n    return null;\n  }\n\n  // Analyze stream quality for suspicious patterns\n  analyzeStreamQuality(video) {\n    try {\n      const videoTracks = video.videoTracks;\n      \n      if (videoTracks && videoTracks.length > 0) {\n        const activeTrack = Array.from(videoTracks).find(track => track.selected);\n        \n        if (activeTrack) {\n          this.streamAnalysis.qualitySwitches.push({\n            label: activeTrack.label,\n            timestamp: Date.now()\n          });\n          \n          // Detect suspicious quality drops (common during ad insertion)\n          if (this.streamAnalysis.qualitySwitches.length > 1) {\n            const lastTwo = this.streamAnalysis.qualitySwitches.slice(-2);\n            \n            if (this.isQualityDowngrade(lastTwo[0].label, lastTwo[1].label)) {\n              console.log('[AdBlock Pro] Suspicious quality downgrade detected');\n            }\n          }\n        }\n      }\n      \n    } catch (e) {\n      console.warn('[AdBlock Pro] Error analyzing stream quality:', e);\n    }\n  }\n\n  // Check if quality was downgraded\n  isQualityDowngrade(oldQuality, newQuality) {\n    const qualities = ['144p', '240p', '360p', '480p', '720p', '1080p', '1440p', '2160p'];\n    const oldIndex = qualities.findIndex(q => oldQuality.includes(q));\n    const newIndex = qualities.findIndex(q => newQuality.includes(q));\n    \n    return oldIndex > newIndex && oldIndex !== -1 && newIndex !== -1;\n  }\n\n  // Monitor HLS/DASH manifests for ad segments\n  monitorManifests() {\n    const originalFetch = window.fetch;\n    \n    window.fetch = function(...args) {\n      const url = args[0];\n      \n      if (typeof url === 'string') {\n        // Monitor m3u8 (HLS) requests\n        if (url.includes('.m3u8')) {\n          return originalFetch.apply(this, args).then(response => {\n            return response.clone().text().then(text => {\n              // Check for ad markers in manifest\n              if (text.includes('#EXT-X-CUE-OUT') || \n                  text.includes('#EXT-X-DISCONTINUITY') ||\n                  text.includes('ad-') ||\n                  text.includes('adsystem')) {\n                console.log('[AdBlock Pro] Ad markers detected in HLS manifest');\n              }\n              \n              return response;\n            });\n          });\n        }\n        \n        // Monitor DASH (MPD) requests\n        if (url.includes('.mpd')) {\n          return originalFetch.apply(this, args).then(response => {\n            return response.clone().text().then(text => {\n              if (text.includes('AdaptationSet') && text.includes('ad')) {\n                console.log('[AdBlock Pro] Ad segments detected in DASH manifest');\n              }\n              \n              return response;\n            });\n          });\n        }\n      }\n      \n      return originalFetch.apply(this, args);\n    };\n  }\n\n  // Get detection statistics\n  getStats() {\n    return {\n      adDetections: this.adDetections,\n      streamInterruptions: this.streamAnalysis.streamInterruptions.length,\n      qualitySwitches: this.streamAnalysis.qualitySwitches.length\n    };\n  }\n\n  // Initialize monitoring\n  initialize() {\n    this.monitorManifests();\n    \n    // Monitor videos every 2 seconds\n    setInterval(() => {\n      this.monitorVideos();\n    }, 2000);\n    \n    // Initial scan\n    this.monitorVideos();\n    \n    console.log('[AdBlock Pro] Video stream detector initialized');\n  }\n}\n\n// Export for use in other scripts\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = VideoStreamDetector;\n}\n","size_bytes":8530},"background.js":{"content":"importScripts(\n  'lib/filter-lists.js',\n  'lib/fingerprint-blocker.js',\n  'lib/notification-system.js',\n  'lib/ml-detector.js'\n);\n\nclass AdBlockProBackground {\n  constructor() {\n    this.filterListManager = new FilterListManager();\n    this.fingerprintBlocker = new FingerprintBlocker();\n    this.notificationSystem = new NotificationSystem();\n    this.mlDetector = new MLAdDetector();\n    \n    this.stats = {\n      total: 0,\n      ads: 0,\n      trackers: 0,\n      miners: 0,\n      malware: 0,\n      fingerprint: 0,\n      social: 0,\n      cookies: 0,\n      sites: new Set(),\n      byDomain: {},\n      history: []\n    };\n\n    this.isEnabled = true;\n    this.whitelist = new Set();\n  }\n\n  async initialize() {\n    console.log('[AdBlock Pro] Inicializando v3.0.0...');\n\n    await this.loadSettings();\n    await this.filterListManager.initialize();\n    await this.fingerprintBlocker.initialize();\n    await this.notificationSystem.initialize();\n    \n    this.setupListeners();\n    this.setupAlarms();\n    \n    await this.updateBadge();\n    \n    console.log('[AdBlock Pro] Inicializaci√≥n completa');\n  }\n\n  async loadSettings() {\n    const stored = await chrome.storage.local.get([\n      'stats', 'isEnabled', 'whitelist', 'settings'\n    ]);\n\n    if (stored.stats) {\n      this.stats = { ...this.stats, ...stored.stats };\n      if (this.stats.sites && Array.isArray(this.stats.sites)) {\n        this.stats.sites = new Set(this.stats.sites);\n      }\n    }\n\n    this.isEnabled = stored.isEnabled !== false;\n    this.whitelist = new Set(stored.whitelist || []);\n    this.settings = stored.settings || {\n      blockLevel: 'advanced',\n      enableML: true,\n      antiFingerprint: true,\n      showNotifications: true\n    };\n  }\n\n  async saveStats() {\n    const statsToSave = {\n      ...this.stats,\n      sites: Array.from(this.stats.sites)\n    };\n    \n    await chrome.storage.local.set({ stats: statsToSave });\n    await this.updateBadge();\n  }\n\n  setupListeners() {\n    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n      this.handleMessage(request, sender, sendResponse);\n      return true;\n    });\n\n    chrome.tabs.onActivated.addListener((activeInfo) => {\n      this.updateBadge(activeInfo.tabId);\n    });\n\n    chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n      if (changeInfo.status === 'complete') {\n        this.injectContentScripts(tabId, tab.url);\n      }\n    });\n\n    chrome.webNavigation.onCommitted.addListener((details) => {\n      if (details.frameId === 0) {\n        this.checkMaliciousSite(details.url, details.tabId);\n      }\n    });\n\n    chrome.webRequest.onCompleted.addListener(\n      (details) => this.analyzeRequest(details),\n      { urls: ['<all_urls>'] }\n    );\n  }\n\n  setupAlarms() {\n    chrome.alarms.create('resetDailyStats', {\n      when: this.getNextMidnight(),\n      periodInMinutes: 1440\n    });\n\n    chrome.alarms.create('updateBadge', {\n      periodInMinutes: 1\n    });\n\n    chrome.alarms.onAlarm.addListener((alarm) => {\n      if (alarm.name === 'resetDailyStats') {\n        this.resetDailyStats();\n      } else if (alarm.name === 'updateBadge') {\n        this.updateBadge();\n      }\n    });\n  }\n\n  getNextMidnight() {\n    const now = new Date();\n    const midnight = new Date(now);\n    midnight.setHours(24, 0, 0, 0);\n    return midnight.getTime();\n  }\n\n  async resetDailyStats() {\n    const today = new Date().toDateString();\n    \n    if (this.stats.history.length > 30) {\n      this.stats.history = this.stats.history.slice(-30);\n    }\n    \n    this.stats.history.push({\n      date: today,\n      blocked: this.stats.total\n    });\n\n    await this.saveStats();\n  }\n\n  async handleMessage(request, sender, sendResponse) {\n    const { type } = request;\n\n    try {\n      switch (type) {\n        case 'GET_STATS':\n          sendResponse(await this.getStats());\n          break;\n\n        case 'GET_SETTINGS':\n          sendResponse({\n            isEnabled: this.isEnabled,\n            settings: this.settings,\n            filterLists: this.filterListManager.getListStats(),\n            fingerprint: this.fingerprintBlocker.getStats(),\n            notifications: this.notificationSystem.getStats()\n          });\n          break;\n\n        case 'TOGGLE_ENABLED':\n          this.isEnabled = request.enabled;\n          await chrome.storage.local.set({ isEnabled: this.isEnabled });\n          await this.updateBadge();\n          sendResponse({ success: true, enabled: this.isEnabled });\n          break;\n\n        case 'ADD_WHITELIST':\n          this.whitelist.add(request.domain);\n          await chrome.storage.local.set({ whitelist: Array.from(this.whitelist) });\n          sendResponse({ success: true });\n          break;\n\n        case 'REMOVE_WHITELIST':\n          this.whitelist.delete(request.domain);\n          await chrome.storage.local.set({ whitelist: Array.from(this.whitelist) });\n          sendResponse({ success: true });\n          break;\n\n        case 'GET_WHITELIST':\n          sendResponse({ whitelist: Array.from(this.whitelist) });\n          break;\n\n        case 'BLOCK_DETECTED':\n          await this.recordBlock(request.data, sender.tab);\n          sendResponse({ success: true });\n          break;\n\n        case 'FINGERPRINT_BLOCKED':\n          this.stats.fingerprint++;\n          await this.notificationSystem.notify('fingerprint', {\n            type: request.fpType,\n            domain: request.domain\n          });\n          await this.saveStats();\n          sendResponse({ success: true });\n          break;\n\n        case 'CUSTOM_RULE_ADDED':\n          console.log('[Background] Nueva regla personalizada:', request.rule);\n          sendResponse({ success: true });\n          break;\n\n        case 'UPDATE_FILTER_LISTS':\n          await this.filterListManager.updateAllLists();\n          sendResponse({ success: true });\n          break;\n\n        case 'TOGGLE_FILTER_LIST':\n          await this.filterListManager.toggleList(request.listKey, request.enabled);\n          sendResponse({ success: true });\n          break;\n\n        case 'EXPORT_DATA':\n          const exportData = await this.exportData();\n          sendResponse(exportData);\n          break;\n\n        case 'IMPORT_DATA':\n          await this.importData(request.data);\n          sendResponse({ success: true });\n          break;\n\n        case 'GET_COSMETIC_RULES':\n          const rules = this.filterListManager.getCosmeticRules(request.domain);\n          sendResponse({ rules });\n          break;\n\n        default:\n          sendResponse({ error: 'Unknown message type' });\n      }\n    } catch (error) {\n      console.error('[Background] Error handling message:', error);\n      sendResponse({ error: error.message });\n    }\n  }\n\n  async analyzeRequest(details) {\n    if (!this.isEnabled) return;\n\n    try {\n      const url = new URL(details.url);\n      const domain = url.hostname;\n\n      if (this.whitelist.has(domain)) {\n        return;\n      }\n\n      if (this.settings.enableML && details.type !== 'main_frame') {\n        const analysis = this.mlDetector.analyzeHTTPRequest(details);\n        if (analysis.isAd && analysis.score > 0.7) {\n          await this.recordBlock({\n            type: analysis.type,\n            url: details.url,\n            category: 'ads',\n            mlScore: analysis.score\n          }, null);\n        }\n      }\n    } catch (error) {\n      console.error('[Background] Error analyzing request:', error);\n    }\n  }\n\n  async recordBlock(data, tab) {\n    const { type, url, category } = data;\n    const domain = url ? new URL(url).hostname : (tab ? new URL(tab.url).hostname : 'unknown');\n\n    this.stats.total++;\n    this.stats.sites.add(domain);\n\n    if (!this.stats.byDomain[domain]) {\n      this.stats.byDomain[domain] = {\n        total: 0,\n        ads: 0,\n        trackers: 0,\n        miners: 0,\n        malware: 0,\n        social: 0\n      };\n    }\n\n    this.stats.byDomain[domain].total++;\n\n    switch (category) {\n      case 'ads':\n        this.stats.ads++;\n        this.stats.byDomain[domain].ads++;\n        break;\n      case 'privacy':\n      case 'tracking':\n        this.stats.trackers++;\n        this.stats.byDomain[domain].trackers++;\n        break;\n      case 'miners':\n        this.stats.miners++;\n        this.stats.byDomain[domain].miners++;\n        break;\n      case 'security':\n        this.stats.malware++;\n        this.stats.byDomain[domain].malware++;\n        await this.notificationSystem.notify('malware', { domain });\n        break;\n      case 'social':\n        this.stats.social++;\n        this.stats.byDomain[domain].social++;\n        break;\n    }\n\n    if (this.settings.enableML && data.mlScore) {\n      this.mlDetector.updateStats(type, true);\n    }\n\n    await this.saveStats();\n  }\n\n  async checkMaliciousSite(url, tabId) {\n    try {\n      const domain = new URL(url).hostname;\n      \n      const maliciousDomains = await this.filterListManager.compiledRules.get('security') || [];\n      const isMalicious = maliciousDomains.some(rule => \n        rule.type === 'domain' && domain.includes(rule.pattern)\n      );\n\n      if (isMalicious) {\n        await this.notificationSystem.notify('malware', { domain, url });\n        \n        await chrome.tabs.update(tabId, {\n          url: `data:text/html,<html><head><title>Sitio Bloqueado</title></head><body style=\"background:#0a0a0a;color:#00d4ff;font-family:sans-serif;text-align:center;padding-top:100px;\"><h1>‚ö†Ô∏è Sitio Peligroso Bloqueado</h1><p>AdBlock Pro ha bloqueado este sitio por seguridad: <strong>${domain}</strong></p><p style=\"color:#94a3b8;\">Este dominio est√° en listas de malware o phishing.</p></body></html>`\n        });\n      }\n    } catch (error) {\n      console.error('[Background] Error checking malicious site:', error);\n    }\n  }\n\n  async injectContentScripts(tabId, url) {\n    if (!url || url.startsWith('chrome://') || url.startsWith('chrome-extension://')) {\n      return;\n    }\n\n    try {\n      await chrome.scripting.executeScript({\n        target: { tabId },\n        files: ['content-script.js']\n      });\n    } catch (error) {\n      console.error('[Background] Error injecting content script:', error);\n    }\n  }\n\n  async updateBadge(tabId) {\n    const text = this.isEnabled ? this.stats.total.toString() : 'OFF';\n    const color = this.isEnabled ? '#00d4ff' : '#ef4444';\n\n    if (tabId) {\n      await chrome.action.setBadgeText({ text, tabId });\n      await chrome.action.setBadgeBackgroundColor({ color, tabId });\n    } else {\n      await chrome.action.setBadgeText({ text });\n      await chrome.action.setBadgeBackgroundColor({ color });\n    }\n  }\n\n  async getStats() {\n    const last7Days = this.stats.history.slice(-7).map(h => ({\n      date: h.date,\n      count: h.blocked\n    }));\n\n    return {\n      total: this.stats.total,\n      ads: this.stats.ads,\n      trackers: this.stats.trackers,\n      miners: this.stats.miners,\n      malware: this.stats.malware,\n      fingerprint: this.stats.fingerprint,\n      social: this.stats.social,\n      sites: this.stats.sites.size,\n      byDomain: this.stats.byDomain,\n      history: last7Days,\n      isEnabled: this.isEnabled,\n      mlStats: this.mlDetector.getStats()\n    };\n  }\n\n  async exportData() {\n    return {\n      version: '3.0.0',\n      timestamp: Date.now(),\n      stats: {\n        ...this.stats,\n        sites: Array.from(this.stats.sites)\n      },\n      whitelist: Array.from(this.whitelist),\n      settings: this.settings,\n      filterLists: this.filterListManager.lists\n    };\n  }\n\n  async importData(data) {\n    if (data.stats) {\n      this.stats = {\n        ...data.stats,\n        sites: new Set(data.stats.sites || [])\n      };\n    }\n    \n    if (data.whitelist) {\n      this.whitelist = new Set(data.whitelist);\n    }\n\n    if (data.settings) {\n      this.settings = data.settings;\n    }\n\n    await chrome.storage.local.set({\n      stats: { ...this.stats, sites: Array.from(this.stats.sites) },\n      whitelist: Array.from(this.whitelist),\n      settings: this.settings\n    });\n\n    await this.saveStats();\n  }\n}\n\nconst adBlockPro = new AdBlockProBackground();\nadBlockPro.initialize().catch(error => {\n  console.error('[AdBlock Pro] Initialization error:', error);\n});\n\nchrome.runtime.onInstalled.addListener((details) => {\n  if (details.reason === 'install') {\n    console.log('[AdBlock Pro] Primera instalaci√≥n - Bienvenido!');\n  } else if (details.reason === 'update') {\n    console.log(`[AdBlock Pro] Actualizado a v3.0.0 desde ${details.previousVersion}`);\n  }\n});\n","size_bytes":12415},"anti-fingerprint.js":{"content":"// Advanced Anti-Fingerprinting Module\n// Protects against browser fingerprinting and tracking\n\n;(() => {\n  'use strict';\n\n  // Canvas Fingerprint Protection\n  function protectCanvas() {\n    const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;\n    const originalToBlob = HTMLCanvasElement.prototype.toBlob;\n    const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;\n\n    // Add noise to canvas data\n    function addCanvasNoise(imageData) {\n      const data = imageData.data;\n      const noise = Math.floor(Math.random() * 10) - 5;\n      \n      for (let i = 0; i < data.length; i += 4) {\n        data[i] = Math.min(255, Math.max(0, data[i] + noise));\n        data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));\n        data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));\n      }\n      \n      return imageData;\n    }\n\n    HTMLCanvasElement.prototype.toDataURL = function(...args) {\n      const context = this.getContext('2d');\n      if (context) {\n        const imageData = context.getImageData(0, 0, this.width, this.height);\n        addCanvasNoise(imageData);\n        context.putImageData(imageData, 0, 0);\n      }\n      return originalToDataURL.apply(this, args);\n    };\n\n    CanvasRenderingContext2D.prototype.getImageData = function(...args) {\n      const imageData = originalGetImageData.apply(this, args);\n      return addCanvasNoise(imageData);\n    };\n\n    Object.defineProperty(HTMLCanvasElement.prototype.toDataURL, 'toString', {\n      value: () => 'function toDataURL() { [native code] }'\n    });\n  }\n\n  // WebGL Fingerprint Protection\n  function protectWebGL() {\n    const getParameter = WebGLRenderingContext.prototype.getParameter;\n    const getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;\n\n    WebGLRenderingContext.prototype.getParameter = function(parameter) {\n      // Randomize vendor and renderer\n      if (parameter === 0x1F00) { // VENDOR\n        return 'Google Inc.';\n      }\n      if (parameter === 0x1F01) { // RENDERER\n        const renderers = [\n          'ANGLE (Intel, Intel(R) UHD Graphics Direct3D11 vs_5_0 ps_5_0)',\n          'ANGLE (NVIDIA, NVIDIA GeForce GTX 1060 Direct3D11 vs_5_0 ps_5_0)',\n          'ANGLE (AMD, AMD Radeon RX 580 Direct3D11 vs_5_0 ps_5_0)'\n        ];\n        return renderers[Math.floor(Math.random() * renderers.length)];\n      }\n      return getParameter.apply(this, arguments);\n    };\n\n    WebGLRenderingContext.prototype.getSupportedExtensions = function() {\n      const extensions = getSupportedExtensions.apply(this, arguments);\n      // Randomize extension list\n      if (Math.random() > 0.5 && extensions) {\n        return extensions.filter(() => Math.random() > 0.1);\n      }\n      return extensions;\n    };\n  }\n\n  // Audio Context Fingerprint Protection\n  function protectAudioContext() {\n    if (typeof AudioContext === 'undefined' && typeof webkitAudioContext === 'undefined') {\n      return;\n    }\n\n    const AudioContextConstructor = window.AudioContext || window.webkitAudioContext;\n    \n    const originalCreateOscillator = AudioContextConstructor.prototype.createOscillator;\n    const originalCreateDynamicsCompressor = AudioContextConstructor.prototype.createDynamicsCompressor;\n\n    AudioContextConstructor.prototype.createOscillator = function() {\n      const oscillator = originalCreateOscillator.apply(this, arguments);\n      const originalStart = oscillator.start;\n      \n      oscillator.start = function(...args) {\n        // Add slight randomization to frequency\n        if (oscillator.frequency) {\n          const noise = (Math.random() - 0.5) * 0.0001;\n          oscillator.frequency.value += noise;\n        }\n        return originalStart.apply(this, args);\n      };\n      \n      return oscillator;\n    };\n\n    AudioContextConstructor.prototype.createDynamicsCompressor = function() {\n      const compressor = originalCreateDynamicsCompressor.apply(this, arguments);\n      \n      // Randomize compressor parameters slightly\n      if (compressor.threshold) {\n        compressor.threshold.value += (Math.random() - 0.5) * 0.1;\n      }\n      if (compressor.knee) {\n        compressor.knee.value += (Math.random() - 0.5) * 0.1;\n      }\n      \n      return compressor;\n    };\n  }\n\n  // Screen Resolution Spoofing\n  function protectScreen() {\n    const originalScreen = {\n      width: screen.width,\n      height: screen.height,\n      availWidth: screen.availWidth,\n      availHeight: screen.availHeight,\n      colorDepth: screen.colorDepth,\n      pixelDepth: screen.pixelDepth\n    };\n\n    // Add random variation\n    const widthVariation = Math.floor(Math.random() * 20) - 10;\n    const heightVariation = Math.floor(Math.random() * 20) - 10;\n\n    Object.defineProperties(screen, {\n      width: { get: () => originalScreen.width + widthVariation },\n      height: { get: () => originalScreen.height + heightVariation },\n      availWidth: { get: () => originalScreen.availWidth + widthVariation },\n      availHeight: { get: () => originalScreen.availHeight + heightVariation }\n    });\n  }\n\n  // Battery API Protection\n  function protectBattery() {\n    if (navigator.getBattery) {\n      const originalGetBattery = navigator.getBattery;\n      navigator.getBattery = function() {\n        return originalGetBattery.apply(this, arguments).then(battery => {\n          Object.defineProperties(battery, {\n            level: { get: () => 0.8 + Math.random() * 0.2 },\n            charging: { get: () => Math.random() > 0.5 }\n          });\n          return battery;\n        });\n      };\n    }\n  }\n\n  // Hardware Concurrency Protection\n  function protectHardware() {\n    Object.defineProperty(navigator, 'hardwareConcurrency', {\n      get: () => {\n        const cores = [2, 4, 6, 8];\n        return cores[Math.floor(Math.random() * cores.length)];\n      }\n    });\n\n    Object.defineProperty(navigator, 'deviceMemory', {\n      get: () => {\n        const memory = [2, 4, 8, 16];\n        return memory[Math.floor(Math.random() * memory.length)];\n      }\n    });\n  }\n\n  // Font Fingerprint Protection\n  function protectFonts() {\n    const originalOffsetWidth = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetWidth');\n    const originalOffsetHeight = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight');\n\n    Object.defineProperty(HTMLElement.prototype, 'offsetWidth', {\n      get: function() {\n        const value = originalOffsetWidth.get.call(this);\n        return value + (Math.random() - 0.5) * 0.1;\n      }\n    });\n\n    Object.defineProperty(HTMLElement.prototype, 'offsetHeight', {\n      get: function() {\n        const value = originalOffsetHeight.get.call(this);\n        return value + (Math.random() - 0.5) * 0.1;\n      }\n    });\n  }\n\n  // Media Devices Protection\n  function protectMediaDevices() {\n    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {\n      const originalEnumerateDevices = navigator.mediaDevices.enumerateDevices;\n      \n      navigator.mediaDevices.enumerateDevices = function() {\n        return originalEnumerateDevices.apply(this, arguments).then(devices => {\n          // Randomize device IDs\n          return devices.map(device => {\n            return {\n              ...device,\n              deviceId: device.deviceId ? 'default' : '',\n              groupId: device.groupId ? 'default' : ''\n            };\n          });\n        });\n      };\n    }\n  }\n\n  // Client Rects Protection\n  function protectClientRects() {\n    const originalGetBoundingClientRect = Element.prototype.getBoundingClientRect;\n    \n    Element.prototype.getBoundingClientRect = function() {\n      const rect = originalGetBoundingClientRect.apply(this, arguments);\n      const noise = (Math.random() - 0.5) * 0.0001;\n      \n      return {\n        ...rect,\n        x: rect.x + noise,\n        y: rect.y + noise,\n        width: rect.width + noise,\n        height: rect.height + noise,\n        top: rect.top + noise,\n        right: rect.right + noise,\n        bottom: rect.bottom + noise,\n        left: rect.left + noise\n      };\n    };\n  }\n\n  // Timezone Protection\n  function protectTimezone() {\n    const originalDate = Date;\n    \n    window.Date = function(...args) {\n      const date = new originalDate(...args);\n      const originalGetTimezoneOffset = date.getTimezoneOffset;\n      \n      date.getTimezoneOffset = function() {\n        // Add random minutes to offset\n        const offset = originalGetTimezoneOffset.apply(this, arguments);\n        return offset + (Math.floor(Math.random() * 30) - 15);\n      };\n      \n      return date;\n    };\n    \n    window.Date.prototype = originalDate.prototype;\n    window.Date.now = originalDate.now;\n    window.Date.parse = originalDate.parse;\n    window.Date.UTC = originalDate.UTC;\n  }\n\n  // Plugin Array Protection\n  function protectPlugins() {\n    Object.defineProperty(navigator, 'plugins', {\n      get: () => {\n        // Return empty or minimal plugin array\n        return [];\n      }\n    });\n\n    Object.defineProperty(navigator, 'mimeTypes', {\n      get: () => {\n        return [];\n      }\n    });\n  }\n\n  // Initialize all protections\n  function initializeProtections() {\n    try {\n      protectCanvas();\n      protectWebGL();\n      protectAudioContext();\n      protectScreen();\n      protectBattery();\n      protectHardware();\n      protectFonts();\n      protectMediaDevices();\n      protectClientRects();\n      protectTimezone();\n      protectPlugins();\n      \n      console.log('[AdBlock Pro] Advanced anti-fingerprinting enabled');\n    } catch (e) {\n      console.warn('[AdBlock Pro] Anti-fingerprinting partial failure:', e);\n    }\n  }\n\n  // Run on page load\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initializeProtections);\n  } else {\n    initializeProtections();\n  }\n})();\n","size_bytes":9791},"ml-detector.js":{"content":"// ML-Based Ad Detection Module\n// Advanced heuristics and pattern recognition\n\nclass MLAdDetector {\n  constructor() {\n    this.features = [];\n    this.adPatterns = [];\n    this.learningEnabled = true;\n    this.detectionStats = {\n      visual: 0,\n      behavioral: 0,\n      nlp: 0,\n      network: 0\n    };\n  }\n\n  // NLP-based detection for persuasive language\n  analyzeText(text) {\n    if (!text || typeof text !== 'string') return { isAd: false, confidence: 0 };\n    \n    const persuasiveKeywords = [\n      // Spanish\n      'compra ahora', 'oferta limitada', 'descuento', 'promoci√≥n', 'solo hoy',\n      '√∫ltimas unidades', 'no te lo pierdas', 'precio especial', 'gratis',\n      'haz clic aqu√≠', 'suscr√≠bete', 'reg√≠strate gratis', 'prueba gratis',\n      // English\n      'buy now', 'limited offer', 'discount', 'promotion', 'today only',\n      'last units', 'don\\'t miss', 'special price', 'free', 'click here',\n      'subscribe', 'sign up free', 'free trial', 'act now', 'limited time',\n      // Action words\n      'shop', 'order', 'reserve', 'claim', 'get yours', 'download now'\n    ];\n    \n    const urgencyWords = [\n      'hurry', 'fast', 'quick', 'now', 'today', 'urgent', 'immediately',\n      'r√°pido', 'ahora', 'hoy', 'urgente', 'inmediato', 'ya'\n    ];\n    \n    const lowerText = text.toLowerCase();\n    let score = 0;\n    \n    persuasiveKeywords.forEach(keyword => {\n      if (lowerText.includes(keyword)) {\n        score += 3;\n      }\n    });\n    \n    urgencyWords.forEach(word => {\n      if (lowerText.includes(word)) {\n        score += 2;\n      }\n    });\n    \n    // Check for excessive capitalization (SHOUTING)\n    const upperCaseRatio = (text.match(/[A-Z]/g) || []).length / text.length;\n    if (upperCaseRatio > 0.5 && text.length > 10) {\n      score += 4;\n    }\n    \n    // Check for excessive punctuation (!!!, ???)\n    const exclamationCount = (text.match(/!/g) || []).length;\n    if (exclamationCount >= 2) {\n      score += 3;\n    }\n    \n    // Check for currency symbols + numbers\n    if (/[\\$‚Ç¨¬£¬•][\\d,]+/.test(text) || /[\\d,]+\\s*(USD|EUR|GBP|dollars|euros)/.test(lowerText)) {\n      score += 2;\n    }\n    \n    const isAd = score >= 8;\n    const confidence = Math.min(score / 15, 1);\n    \n    if (isAd) {\n      this.detectionStats.nlp++;\n    }\n    \n    return { isAd, confidence, score };\n  }\n\n  // Perceptual detection - analyze visual characteristics\n  analyzeElement(element) {\n    if (!element) return { isAd: false, confidence: 0 };\n    \n    let score = 0;\n    const features = [];\n    \n    try {\n      const rect = element.getBoundingClientRect();\n      const computedStyle = window.getComputedStyle(element);\n      \n      // Common ad dimensions\n      const commonAdSizes = [\n        { w: 300, h: 250 }, { w: 728, h: 90 }, { w: 160, h: 600 },\n        { w: 336, h: 280 }, { w: 300, h: 600 }, { w: 970, h: 250 },\n        { w: 300, h: 50 }, { w: 320, h: 100 }, { w: 468, h: 60 }\n      ];\n      \n      const matchesAdSize = commonAdSizes.some(size => \n        Math.abs(rect.width - size.w) < 10 && Math.abs(rect.height - size.h) < 10\n      );\n      \n      if (matchesAdSize) {\n        score += 5;\n        features.push('standard-ad-size');\n      }\n      \n      // Check z-index (ads often on top)\n      const zIndex = parseInt(computedStyle.zIndex) || 0;\n      if (zIndex > 1000) {\n        score += 3;\n        features.push('high-z-index');\n      }\n      \n      // Check for fixed/sticky positioning (overlay ads)\n      if (computedStyle.position === 'fixed' || computedStyle.position === 'sticky') {\n        score += 2;\n        features.push('fixed-position');\n      }\n      \n      // Check for iframe\n      if (element.tagName === 'IFRAME') {\n        const src = element.src || '';\n        if (src.includes('doubleclick') || src.includes('googlesyndication') || \n            src.includes('ad') || src.includes('banner')) {\n          score += 6;\n          features.push('ad-iframe');\n        }\n      }\n      \n      // Check text content for ad indicators\n      const textContent = element.textContent || '';\n      const nlpResult = this.analyzeText(textContent);\n      if (nlpResult.isAd) {\n        score += nlpResult.score;\n        features.push('persuasive-text');\n      }\n      \n      // Check for \"Ad\" or \"Sponsored\" disclosure\n      const hasDisclosure = /\\b(ad|ads|anuncio|publicidad|sponsored|patrocinado)\\b/i.test(textContent);\n      if (hasDisclosure) {\n        score += 7;\n        features.push('ad-disclosure');\n      }\n      \n      // Check classes and IDs\n      const className = element.className || '';\n      const id = element.id || '';\n      const classIdText = `${className} ${id}`.toLowerCase();\n      \n      const adIdentifiers = [\n        'ad', 'ads', 'banner', 'sponsor', 'promo', 'advertisement',\n        'advert', 'commercial', 'publicity', 'publicidad'\n      ];\n      \n      if (adIdentifiers.some(identifier => classIdText.includes(identifier))) {\n        score += 4;\n        features.push('ad-class-id');\n      }\n      \n      // Check for background images (common in banner ads)\n      const bgImage = computedStyle.backgroundImage;\n      if (bgImage && bgImage !== 'none') {\n        if (bgImage.includes('ad') || bgImage.includes('banner')) {\n          score += 3;\n          features.push('ad-bg-image');\n        }\n      }\n      \n      const isAd = score >= 10;\n      const confidence = Math.min(score / 20, 1);\n      \n      if (isAd) {\n        this.detectionStats.visual++;\n      }\n      \n      return { isAd, confidence, score, features };\n      \n    } catch (e) {\n      return { isAd: false, confidence: 0, error: e.message };\n    }\n  }\n\n  // Behavioral detection - analyze user interaction patterns\n  analyzeBehavior(element) {\n    if (!element) return { isSuspicious: false };\n    \n    let suspicionScore = 0;\n    \n    // Check if element opens new windows on click\n    const hasTargetBlank = element.getAttribute('target') === '_blank';\n    if (hasTargetBlank) suspicionScore += 2;\n    \n    // Check for redirect chains\n    const href = element.href || element.getAttribute('href') || '';\n    if (href && href.includes('redirect') || href.includes('click') || href.includes('track')) {\n      suspicionScore += 3;\n    }\n    \n    // Check for multiple nested iframes (ad networks)\n    if (element.tagName === 'IFRAME') {\n      let parent = element.parentElement;\n      let iframeDepth = 0;\n      while (parent && iframeDepth < 5) {\n        if (parent.tagName === 'IFRAME') iframeDepth++;\n        parent = parent.parentElement;\n      }\n      if (iframeDepth >= 2) {\n        suspicionScore += 4;\n      }\n    }\n    \n    const isSuspicious = suspicionScore >= 5;\n    \n    if (isSuspicious) {\n      this.detectionStats.behavioral++;\n    }\n    \n    return { isSuspicious, suspicionScore };\n  }\n\n  // Network pattern analysis - detect CNAME cloaking\n  analyzeNetworkRequest(url) {\n    if (!url) return { isCloaked: false };\n    \n    try {\n      const urlObj = new URL(url);\n      const hostname = urlObj.hostname;\n      const path = urlObj.pathname;\n      \n      // Check for CNAME cloaking patterns\n      const cloakingIndicators = [\n        hostname.includes('ads.'),\n        hostname.includes('track.'),\n        hostname.includes('analytics.'),\n        hostname.includes('cdn.') && path.includes('/ad'),\n        hostname.includes('static.') && path.includes('/banner'),\n        path.includes('/track/'),\n        path.includes('/pixel/'),\n        path.includes('/beacon/')\n      ];\n      \n      const isCloaked = cloakingIndicators.filter(Boolean).length >= 2;\n      \n      if (isCloaked) {\n        this.detectionStats.network++;\n      }\n      \n      return { isCloaked, hostname, indicators: cloakingIndicators.filter(Boolean) };\n      \n    } catch (e) {\n      return { isCloaked: false, error: e.message };\n    }\n  }\n\n  // Comprehensive scan of entire page\n  scanPage() {\n    const detections = [];\n    const allElements = document.querySelectorAll('*');\n    \n    allElements.forEach(element => {\n      const visual = this.analyzeElement(element);\n      const behavioral = this.analyzeBehavior(element);\n      \n      if (visual.isAd || behavioral.isSuspicious) {\n        detections.push({\n          element,\n          visual,\n          behavioral,\n          timestamp: Date.now()\n        });\n      }\n    });\n    \n    return detections;\n  }\n\n  // Get detection statistics\n  getStats() {\n    return {\n      ...this.detectionStats,\n      total: Object.values(this.detectionStats).reduce((a, b) => a + b, 0)\n    };\n  }\n\n  // Reset statistics\n  resetStats() {\n    this.detectionStats = {\n      visual: 0,\n      behavioral: 0,\n      nlp: 0,\n      network: 0\n    };\n  }\n}\n\n// Export for use in other scripts\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = MLAdDetector;\n}\n","size_bytes":8754}},"version":2}